// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

package ccxt

import (
	"C"
	"encoding/json"
	"fmt"
	"math"
	"regexp"
	"strings"
	"sync"
	   ccxt "github.com/ccxt/ccxt/go/v4"
)
type CCXTGoExchange struct {
	exchange ccxt.ICoreExchange
}

func NewExchange(exchangeName string, configJson string) *CCXTGoExchange {
	
	// First, remove the outer quotes if they exist
	configJson = strings.Trim(configJson, "\"")

	// Convert JavaScript object syntax to valid JSON:
	// 1. Replace single quotes with double quotes
	configJson = strings.ReplaceAll(configJson, "'", "\"")
	// 2. Add double quotes to unquoted keys
	configJson = regexp.MustCompile(`(\w+):`).ReplaceAllString(configJson, "\"$1\":")

	var config map[string]interface{}
	if err := json.Unmarshal([]byte(configJson), &config); err != nil {
		fmt.Printf("Go: Failed to parse configJson: %v\nInput was: %s\nProcessed to: %s\n", err, configJson, configJson)
		return nil
	}
	
    var inst, ok = ccxt.DynamicallyCreateInstance(exchangeName, config)

	if !ok {
		return nil
	}

	return &CCXTGoExchange{exchange: inst}
}

func parseJSON(input string) []byte {
	var intermediate string
	if err := json.Unmarshal([]byte(input), &intermediate); err == nil {
		// Input was a double-quoted JSON string â€” unwrap it
		input = intermediate
	}

	var anything interface{}
	if err := json.Unmarshal([]byte(input), &anything); err != nil {
		// Return a consistent error message as JSON
		errorObj := map[string]string{"error": "Invalid JSON"}
		b, _ := json.Marshal(errorObj)
		return b
	}

	b, _ := json.Marshal(anything)
	return b
}

func sanitise(v interface{}) interface{} {
	switch x := v.(type) {
	case float64:
		if math.IsNaN(x) || math.IsInf(x, 0) {
			return nil
		}
		return x
	case map[string]interface{}:
		out := make(map[string]interface{}, len(x))
		for k, vv := range x {
			out[k] = sanitise(vv)
		}
		return out
	case []interface{}:
		out := make([]interface{}, len(x))
		for i, vv := range x {
			out[i] = sanitise(vv)
		}
		return out
	default:
		return v
	}
}

// ------------------------------------------------------------------------

// ########################################################################
// ########################################################################
// ########################################################################
// ########################################################################
// ########                        ########                        ########
// ########                        ########                        ########
// ########                        ########                        ########
// ########                        ########                        ########
// ########        ########################        ########################
// ########        ########################        ########################
// ########        ########################        ########################
// ########        ########################        ########################
// ########                        ########                        ########
// ########                        ########                        ########
// ########                        ########                        ########
// ########                        ########                        ########
// ########################################################################
// ########################################################################
// ########################################################################
// ########################################################################
// ########        ########        ########                        ########
// ########        ########        ########                        ########
// ########        ########        ########                        ########
// ########        ########        ########                        ########
// ################        ########################        ################
// ################        ########################        ################
// ################        ########################        ################
// ################        ########################        ################
// ########        ########        ################        ################
// ########        ########        ################        ################
// ########        ########        ################        ################
// ########        ########        ################        ################
// ########################################################################
// ########################################################################
// ########################################################################
// ########################################################################

// ------------------------------------------------------------------------
// METHODS BELOW THIS LINE ARE TRANSPILED


func (e *CCXTGoExchange) GetIsSandboxModeEnabled() ([]byte, error) {
        propValue := e.exchange.GetIsSandboxModeEnabled()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetIsSandboxModeEnabled(newValue bool) error {
        
        e.exchange.SetIsSandboxModeEnabled(newValue)
        return nil
    }


func (e *CCXTGoExchange) GetApi() ([]byte, error) {
        propValue := e.exchange.GetApi()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }




func (e *CCXTGoExchange) GetUserAgent() ([]byte, error) {
        propValue := e.exchange.GetUserAgent()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetUserAgent(newValue string) error {
        
        e.exchange.SetUserAgent(newValue)
        return nil
    }


func (e *CCXTGoExchange) GetUserAgents() ([]byte, error) {
        propValue := e.exchange.GetUserAgents()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetUserAgents(newValue []byte) error {
        
        var decoded map[string]interface{}
	    if err := json.Unmarshal(newValue, &decoded); err != nil {
		    return err
	    }
        e.exchange.SetUserAgents(decoded)
        return nil
    }


func (e *CCXTGoExchange) GetReturnResponseHeaders() ([]byte, error) {
        propValue := e.exchange.GetReturnResponseHeaders()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetReturnResponseHeaders(newValue bool) error {
        
        e.exchange.SetReturnResponseHeaders(newValue)
        return nil
    }


func (e *CCXTGoExchange) GetMAX_VALUE() ([]byte, error) {
        propValue := e.exchange.GetMAX_VALUE()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetMAX_VALUE(newValue float64) error {
        
        e.exchange.SetMAX_VALUE(newValue)
        return nil
    }


func (e *CCXTGoExchange) GetSubstituteCommonCurrencyCodes() ([]byte, error) {
        propValue := e.exchange.GetSubstituteCommonCurrencyCodes()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetSubstituteCommonCurrencyCodes(newValue bool) error {
        
        e.exchange.SetSubstituteCommonCurrencyCodes(newValue)
        return nil
    }


func (e *CCXTGoExchange) GetReduceFees() ([]byte, error) {
        propValue := e.exchange.GetReduceFees()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetReduceFees(newValue bool) error {
        
        e.exchange.SetReduceFees(newValue)
        return nil
    }




func (e *CCXTGoExchange) SetTimeout(newValue int64) error {
        
        e.exchange.SetTimeout(newValue)
        return nil
    }




func (e *CCXTGoExchange) SetVerbose(newValue bool) error {
        
        e.exchange.SetVerbose(newValue)
        return nil
    }




func (e *CCXTGoExchange) SetTwofa(newValue string) error {
        
        e.exchange.SetTwofa(newValue)
        return nil
    }


func (e *CCXTGoExchange) GetBalance() ([]byte, error) {
        propValue := e.exchange.GetBalance()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetBalance(newValue []byte) error {
        
        var decoded interface{}
	    if err := json.Unmarshal(newValue, &decoded); err != nil {
		    return err
	    }
        e.exchange.SetBalance(decoded)
        return nil
    }


func (e *CCXTGoExchange) GetLiquidations() ([]byte, error) {
        propValue := e.exchange.GetLiquidations()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetLiquidations(newValue []byte) error {
        
        var decoded *sync.Map
	    if err := json.Unmarshal(newValue, &decoded); err != nil {
		    return err
	    }
        e.exchange.SetLiquidations(decoded)
        return nil
    }


func (e *CCXTGoExchange) GetOrderbooks() ([]byte, error) {
        propValue := e.exchange.GetOrderbooks()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetOrderbooks(newValue []byte) error {
        
        var decoded *sync.Map
	    if err := json.Unmarshal(newValue, &decoded); err != nil {
		    return err
	    }
        e.exchange.SetOrderbooks(decoded)
        return nil
    }


func (e *CCXTGoExchange) GetTickers() ([]byte, error) {
        propValue := e.exchange.GetTickers()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetTickers(newValue []byte) error {
        
        var decoded *sync.Map
	    if err := json.Unmarshal(newValue, &decoded); err != nil {
		    return err
	    }
        e.exchange.SetTickers(decoded)
        return nil
    }


func (e *CCXTGoExchange) GetFundingRates() ([]byte, error) {
        propValue := e.exchange.GetFundingRates()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetFundingRates(newValue []byte) error {
        
        var decoded interface{}
	    if err := json.Unmarshal(newValue, &decoded); err != nil {
		    return err
	    }
        e.exchange.SetFundingRates(decoded)
        return nil
    }


func (e *CCXTGoExchange) GetBidsasks() ([]byte, error) {
        propValue := e.exchange.GetBidsasks()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetBidsasks(newValue []byte) error {
        
        var decoded *sync.Map
	    if err := json.Unmarshal(newValue, &decoded); err != nil {
		    return err
	    }
        e.exchange.SetBidsasks(decoded)
        return nil
    }


func (e *CCXTGoExchange) GetOrders() ([]byte, error) {
        propValue := e.exchange.GetOrders()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetOrders(newValue []byte) error {
        
        var decoded interface{}
	    if err := json.Unmarshal(newValue, &decoded); err != nil {
		    return err
	    }
        e.exchange.SetOrders(decoded)
        return nil
    }


func (e *CCXTGoExchange) GetTriggerOrders() ([]byte, error) {
        propValue := e.exchange.GetTriggerOrders()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetTriggerOrders(newValue []byte) error {
        
        var decoded interface{}
	    if err := json.Unmarshal(newValue, &decoded); err != nil {
		    return err
	    }
        e.exchange.SetTriggerOrders(decoded)
        return nil
    }


func (e *CCXTGoExchange) GetTransactions() ([]byte, error) {
        propValue := e.exchange.GetTransactions()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetTransactions(newValue []byte) error {
        
        var decoded *sync.Map
	    if err := json.Unmarshal(newValue, &decoded); err != nil {
		    return err
	    }
        e.exchange.SetTransactions(decoded)
        return nil
    }


func (e *CCXTGoExchange) GetMyLiquidations() ([]byte, error) {
        propValue := e.exchange.GetMyLiquidations()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetMyLiquidations(newValue []byte) error {
        
        var decoded *sync.Map
	    if err := json.Unmarshal(newValue, &decoded); err != nil {
		    return err
	    }
        e.exchange.SetMyLiquidations(decoded)
        return nil
    }


func (e *CCXTGoExchange) GetPrecision() ([]byte, error) {
        propValue := e.exchange.GetPrecision()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetPrecision(newValue []byte) error {
        
        var decoded map[string]interface{}
	    if err := json.Unmarshal(newValue, &decoded); err != nil {
		    return err
	    }
        e.exchange.SetPrecision(decoded)
        return nil
    }


func (e *CCXTGoExchange) GetLast_http_response() ([]byte, error) {
        propValue := e.exchange.GetLast_http_response()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetLast_http_response(newValue []byte) error {
        
        var decoded interface{}
	    if err := json.Unmarshal(newValue, &decoded); err != nil {
		    return err
	    }
        e.exchange.SetLast_http_response(decoded)
        return nil
    }


func (e *CCXTGoExchange) GetLast_request_headers() ([]byte, error) {
        propValue := e.exchange.GetLast_request_headers()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }




func (e *CCXTGoExchange) GetLast_request_body() ([]byte, error) {
        propValue := e.exchange.GetLast_request_body()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }




func (e *CCXTGoExchange) GetLast_request_url() ([]byte, error) {
        propValue := e.exchange.GetLast_request_url()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }




func (e *CCXTGoExchange) GetLastRequestBody() ([]byte, error) {
        propValue := e.exchange.GetLastRequestBody()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetLastRequestBody(newValue []byte) error {
        
        var decoded interface{}
	    if err := json.Unmarshal(newValue, &decoded); err != nil {
		    return err
	    }
        e.exchange.SetLastRequestBody(decoded)
        return nil
    }


func (e *CCXTGoExchange) GetLastRequestUrl() ([]byte, error) {
        propValue := e.exchange.GetLastRequestUrl()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetLastRequestUrl(newValue string) error {
        
        e.exchange.SetLastRequestUrl(newValue)
        return nil
    }


func (e *CCXTGoExchange) GetId() ([]byte, error) {
        propValue := e.exchange.GetId()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }




func (e *CCXTGoExchange) GetMarkets() ([]byte, error) {
        propValue := e.exchange.GetMarkets()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }




func (e *CCXTGoExchange) GetFeatures() ([]byte, error) {
        propValue := e.exchange.GetFeatures()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }




func (e *CCXTGoExchange) GetRateLimit() ([]byte, error) {
        propValue := e.exchange.GetRateLimit()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetRateLimit(newValue float64) error {
        
        e.exchange.SetRateLimit(newValue)
        return nil
    }


func (e *CCXTGoExchange) GetTokenBucket() ([]byte, error) {
        propValue := e.exchange.GetTokenBucket()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetTokenBucket(newValue []byte) error {
        
        var decoded map[string]interface{}
	    if err := json.Unmarshal(newValue, &decoded); err != nil {
		    return err
	    }
        e.exchange.SetTokenBucket(decoded)
        return nil
    }


func (e *CCXTGoExchange) GetThrottler() ([]byte, error) {
        propValue := e.exchange.GetThrottler()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetThrottler(newValue []byte) error {
        
        var decoded *ccxt.Throttler
	    if err := json.Unmarshal(newValue, &decoded); err != nil {
		    return err
	    }
        e.exchange.SetThrottler(decoded)
        return nil
    }




func (e *CCXTGoExchange) SetEnableRateLimit(newValue bool) error {
        
        e.exchange.SetEnableRateLimit(newValue)
        return nil
    }


func (e *CCXTGoExchange) GetHttpExceptions() ([]byte, error) {
        propValue := e.exchange.GetHttpExceptions()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetHttpExceptions(newValue []byte) error {
        
        var decoded map[string]interface{}
	    if err := json.Unmarshal(newValue, &decoded); err != nil {
		    return err
	    }
        e.exchange.SetHttpExceptions(decoded)
        return nil
    }


func (e *CCXTGoExchange) GetLimits() ([]byte, error) {
        propValue := e.exchange.GetLimits()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetLimits(newValue []byte) error {
        
        var decoded map[string]interface{}
	    if err := json.Unmarshal(newValue, &decoded); err != nil {
		    return err
	    }
        e.exchange.SetLimits(decoded)
        return nil
    }


func (e *CCXTGoExchange) GetMarkets_by_id() ([]byte, error) {
        propValue := e.exchange.GetMarkets_by_id()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetMarkets_by_id(newValue []byte) error {
        
        var decoded *sync.Map
	    if err := json.Unmarshal(newValue, &decoded); err != nil {
		    return err
	    }
        e.exchange.SetMarkets_by_id(decoded)
        return nil
    }


func (e *CCXTGoExchange) GetSymbols() ([]byte, error) {
        propValue := e.exchange.GetSymbols()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }




func (e *CCXTGoExchange) GetIds() ([]byte, error) {
        propValue := e.exchange.GetIds()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetIds(newValue []byte) error {
        
        var decoded []string
	    if err := json.Unmarshal(newValue, &decoded); err != nil {
		    return err
	    }
        e.exchange.SetIds(decoded)
        return nil
    }


func (e *CCXTGoExchange) GetCurrencies() ([]byte, error) {
        propValue := e.exchange.GetCurrencies()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetCurrencies(newValue []byte) error {
        
        var decoded ccxt.Currencies
	    if err := json.Unmarshal(newValue, &decoded); err != nil {
		    return err
	    }
        e.exchange.SetCurrencies(decoded)
        return nil
    }


func (e *CCXTGoExchange) GetBaseCurrencies() ([]byte, error) {
        propValue := e.exchange.GetBaseCurrencies()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetBaseCurrencies(newValue []byte) error {
        
        var decoded *sync.Map
	    if err := json.Unmarshal(newValue, &decoded); err != nil {
		    return err
	    }
        e.exchange.SetBaseCurrencies(decoded)
        return nil
    }


func (e *CCXTGoExchange) GetQuoteCurrencies() ([]byte, error) {
        propValue := e.exchange.GetQuoteCurrencies()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetQuoteCurrencies(newValue []byte) error {
        
        var decoded *sync.Map
	    if err := json.Unmarshal(newValue, &decoded); err != nil {
		    return err
	    }
        e.exchange.SetQuoteCurrencies(decoded)
        return nil
    }


func (e *CCXTGoExchange) GetCurrencies_by_id() ([]byte, error) {
        propValue := e.exchange.GetCurrencies_by_id()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetCurrencies_by_id(newValue []byte) error {
        
        var decoded *sync.Map
	    if err := json.Unmarshal(newValue, &decoded); err != nil {
		    return err
	    }
        e.exchange.SetCurrencies_by_id(decoded)
        return nil
    }


func (e *CCXTGoExchange) GetCodes() ([]byte, error) {
        propValue := e.exchange.GetCodes()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetCodes(newValue []byte) error {
        
        var decoded []string
	    if err := json.Unmarshal(newValue, &decoded); err != nil {
		    return err
	    }
        e.exchange.SetCodes(decoded)
        return nil
    }




func (e *CCXTGoExchange) SetAccounts(newValue []byte) error {
        
        var decoded []ccxt.Account
	    if err := json.Unmarshal(newValue, &decoded); err != nil {
		    return err
	    }
        e.exchange.SetAccounts(decoded)
        return nil
    }


func (e *CCXTGoExchange) GetAccountsById() ([]byte, error) {
        propValue := e.exchange.GetAccountsById()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetAccountsById(newValue []byte) error {
        
        var decoded interface{}
	    if err := json.Unmarshal(newValue, &decoded); err != nil {
		    return err
	    }
        e.exchange.SetAccountsById(decoded)
        return nil
    }


func (e *CCXTGoExchange) GetCommonCurrencies() ([]byte, error) {
        propValue := e.exchange.GetCommonCurrencies()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetCommonCurrencies(newValue []byte) error {
        
        var decoded map[string]interface{}
	    if err := json.Unmarshal(newValue, &decoded); err != nil {
		    return err
	    }
        e.exchange.SetCommonCurrencies(decoded)
        return nil
    }


func (e *CCXTGoExchange) GetHostname() ([]byte, error) {
        propValue := e.exchange.GetHostname()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }




func (e *CCXTGoExchange) GetExceptions() ([]byte, error) {
        propValue := e.exchange.GetExceptions()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetExceptions(newValue []byte) error {
        
        var decoded map[string]interface{}
	    if err := json.Unmarshal(newValue, &decoded); err != nil {
		    return err
	    }
        e.exchange.SetExceptions(decoded)
        return nil
    }


func (e *CCXTGoExchange) GetTimeframes() ([]byte, error) {
        propValue := e.exchange.GetTimeframes()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }




func (e *CCXTGoExchange) GetVersion() ([]byte, error) {
        propValue := e.exchange.GetVersion()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }




func (e *CCXTGoExchange) GetName() ([]byte, error) {
        propValue := e.exchange.GetName()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetName(newValue string) error {
        
        e.exchange.SetName(newValue)
        return nil
    }


func (e *CCXTGoExchange) GetHttpProxyAgentModule() ([]byte, error) {
        propValue := e.exchange.GetHttpProxyAgentModule()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetHttpProxyAgentModule(newValue []byte) error {
        
        var decoded interface{}
	    if err := json.Unmarshal(newValue, &decoded); err != nil {
		    return err
	    }
        e.exchange.SetHttpProxyAgentModule(decoded)
        return nil
    }


func (e *CCXTGoExchange) GetHttpsProxyAgentModule() ([]byte, error) {
        propValue := e.exchange.GetHttpsProxyAgentModule()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetHttpsProxyAgentModule(newValue []byte) error {
        
        var decoded interface{}
	    if err := json.Unmarshal(newValue, &decoded); err != nil {
		    return err
	    }
        e.exchange.SetHttpsProxyAgentModule(decoded)
        return nil
    }


func (e *CCXTGoExchange) GetSocksProxyAgentModule() ([]byte, error) {
        propValue := e.exchange.GetSocksProxyAgentModule()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetSocksProxyAgentModule(newValue []byte) error {
        
        var decoded interface{}
	    if err := json.Unmarshal(newValue, &decoded); err != nil {
		    return err
	    }
        e.exchange.SetSocksProxyAgentModule(decoded)
        return nil
    }


func (e *CCXTGoExchange) GetSocksProxyAgentModuleChecked() ([]byte, error) {
        propValue := e.exchange.GetSocksProxyAgentModuleChecked()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetSocksProxyAgentModuleChecked(newValue bool) error {
        
        e.exchange.SetSocksProxyAgentModuleChecked(newValue)
        return nil
    }


func (e *CCXTGoExchange) GetProxyDictionaries() ([]byte, error) {
        propValue := e.exchange.GetProxyDictionaries()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetProxyDictionaries(newValue []byte) error {
        
        var decoded map[string]interface{}
	    if err := json.Unmarshal(newValue, &decoded); err != nil {
		    return err
	    }
        e.exchange.SetProxyDictionaries(decoded)
        return nil
    }


func (e *CCXTGoExchange) GetAlias() ([]byte, error) {
        propValue := e.exchange.GetAlias()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }




func (e *CCXTGoExchange) GetClients() ([]byte, error) {
        propValue := e.exchange.GetClients()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetClients(newValue []byte) error {
        
        var decoded map[string]interface{}
	    if err := json.Unmarshal(newValue, &decoded); err != nil {
		    return err
	    }
        e.exchange.SetClients(decoded)
        return nil
    }


func (e *CCXTGoExchange) GetNewUpdates() ([]byte, error) {
        propValue := e.exchange.GetNewUpdates()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetNewUpdates(newValue bool) error {
        
        e.exchange.SetNewUpdates(newValue)
        return nil
    }


func (e *CCXTGoExchange) GetOptions() ([]byte, error) {
        propValue := e.exchange.GetOptions()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetOptions(newValue []byte) error {
        
        var decoded map[string]interface{}
	    if err := json.Unmarshal(newValue, &decoded); err != nil {
		    return err
	    }
        e.exchange.SetOptions(decoded)
        return nil
    }




func (e *CCXTGoExchange) SetApiKey(newValue string) error {
        
        e.exchange.SetApiKey(newValue)
        return nil
    }




func (e *CCXTGoExchange) SetSecret(newValue string) error {
        
        e.exchange.SetSecret(newValue)
        return nil
    }




func (e *CCXTGoExchange) SetUid(newValue string) error {
        
        e.exchange.SetUid(newValue)
        return nil
    }


func (e *CCXTGoExchange) GetLogin() ([]byte, error) {
        propValue := e.exchange.GetLogin()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetLogin(newValue string) error {
        
        e.exchange.SetLogin(newValue)
        return nil
    }




func (e *CCXTGoExchange) SetPassword(newValue string) error {
        
        e.exchange.SetPassword(newValue)
        return nil
    }




func (e *CCXTGoExchange) SetPrivateKey(newValue string) error {
        
        e.exchange.SetPrivateKey(newValue)
        return nil
    }




func (e *CCXTGoExchange) SetWalletAddress(newValue string) error {
        
        e.exchange.SetWalletAddress(newValue)
        return nil
    }


func (e *CCXTGoExchange) GetToken() ([]byte, error) {
        propValue := e.exchange.GetToken()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetToken(newValue string) error {
        
        e.exchange.SetToken(newValue)
        return nil
    }


func (e *CCXTGoExchange) GetTrades() ([]byte, error) {
        propValue := e.exchange.GetTrades()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetTrades(newValue []byte) error {
        
        var decoded interface{}
	    if err := json.Unmarshal(newValue, &decoded); err != nil {
		    return err
	    }
        e.exchange.SetTrades(decoded)
        return nil
    }


func (e *CCXTGoExchange) GetOhlcvs() ([]byte, error) {
        propValue := e.exchange.GetOhlcvs()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetOhlcvs(newValue []byte) error {
        
        var decoded interface{}
	    if err := json.Unmarshal(newValue, &decoded); err != nil {
		    return err
	    }
        e.exchange.SetOhlcvs(decoded)
        return nil
    }


func (e *CCXTGoExchange) GetMyTrades() ([]byte, error) {
        propValue := e.exchange.GetMyTrades()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetMyTrades(newValue []byte) error {
        
        var decoded interface{}
	    if err := json.Unmarshal(newValue, &decoded); err != nil {
		    return err
	    }
        e.exchange.SetMyTrades(decoded)
        return nil
    }


func (e *CCXTGoExchange) GetPositions() ([]byte, error) {
        propValue := e.exchange.GetPositions()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetPositions(newValue []byte) error {
        
        var decoded interface{}
	    if err := json.Unmarshal(newValue, &decoded); err != nil {
		    return err
	    }
        e.exchange.SetPositions(decoded)
        return nil
    }


func (e *CCXTGoExchange) GetHas() ([]byte, error) {
        propValue := e.exchange.GetHas()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }




func (e *CCXTGoExchange) GetUrls() ([]byte, error) {
        propValue := e.exchange.GetUrls()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }




func (e *CCXTGoExchange) GetRequiredCredentials() ([]byte, error) {
        propValue := e.exchange.GetRequiredCredentials()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }




func (e *CCXTGoExchange) GetFees() ([]byte, error) {
        propValue := e.exchange.GetFees()
        sanitised := sanitise(propValue)
        return json.Marshal(sanitised)
    }

func (e *CCXTGoExchange) SetFees(newValue []byte) error {
        
        var decoded map[string]interface{}
	    if err := json.Unmarshal(newValue, &decoded); err != nil {
		    return err
	    }
        e.exchange.SetFees(decoded)
        return nil
    }


    func (e *CCXTGoExchange) LoadMarkets(reload bool, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.LoadMarkets(reload, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchCurrencies(params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.FetchCurrencies(decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchMarkets(params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.FetchMarkets(decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) SetSandboxMode(enabled bool) error {
        
        
        
        e.exchange.SetSandboxMode(enabled)
		return nil
    }

    func (e *CCXTGoExchange) FetchAccounts(params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.FetchAccounts(decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchTrades(symbol string, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            } else {
                since = v
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            } else {
                limit = v
            }
            delete(decoded, "limit")
        }
        
        
        res := <-e.exchange.FetchTrades(symbol, since, limit, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchDepositAddresses(params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var codes interface{} = nil
        if v, ok := decoded["codes"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                codes = f
            } else {
                codes = v
            }
            delete(decoded, "codes")
        }
        
        
        res := <-e.exchange.FetchDepositAddresses(codes, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchOrderBook(symbol string, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            } else {
                limit = v
            }
            delete(decoded, "limit")
        }
        
        
        res := <-e.exchange.FetchOrderBook(symbol, limit, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchMarginMode(symbol string, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.FetchMarginMode(symbol, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchMarginModes(params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbols interface{} = nil
        if v, ok := decoded["symbols"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbols = f
            } else {
                symbols = v
            }
            delete(decoded, "symbols")
        }
        
        
        res := <-e.exchange.FetchMarginModes(symbols, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchTime(params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.FetchTime(decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchTradingLimits(params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbols interface{} = nil
        if v, ok := decoded["symbols"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbols = f
            } else {
                symbols = v
            }
            delete(decoded, "symbols")
        }
        
        
        res := <-e.exchange.FetchTradingLimits(symbols, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchCrossBorrowRates(params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.FetchCrossBorrowRates(decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchIsolatedBorrowRates(params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.FetchIsolatedBorrowRates(decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchLeverageTiers(params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbols interface{} = nil
        if v, ok := decoded["symbols"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbols = f
            } else {
                symbols = v
            }
            delete(decoded, "symbols")
        }
        
        
        res := <-e.exchange.FetchLeverageTiers(symbols, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchFundingRates(params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbols interface{} = nil
        if v, ok := decoded["symbols"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbols = f
            } else {
                symbols = v
            }
            delete(decoded, "symbols")
        }
        
        
        res := <-e.exchange.FetchFundingRates(symbols, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchFundingIntervals(params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbols interface{} = nil
        if v, ok := decoded["symbols"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbols = f
            } else {
                symbols = v
            }
            delete(decoded, "symbols")
        }
        
        
        res := <-e.exchange.FetchFundingIntervals(symbols, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) Transfer(code string, amount float64, fromAccount string, toAccount string, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.Transfer(code, amount, fromAccount, toAccount, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) Withdraw(code string, amount float64, address string, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var tag interface{} = nil
        if v, ok := decoded["tag"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                tag = f
            } else {
                tag = v
            }
            delete(decoded, "tag")
        }
        
        
        res := <-e.exchange.Withdraw(code, amount, address, tag, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) CreateDepositAddress(code string, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.CreateDepositAddress(code, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) SetLeverage(leverage int, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbol interface{} = nil
        if v, ok := decoded["symbol"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbol = f
            } else {
                symbol = v
            }
            delete(decoded, "symbol")
        }
        
        
        res := <-e.exchange.SetLeverage(leverage, symbol, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchLeverage(symbol string, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.FetchLeverage(symbol, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchLeverages(params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbols interface{} = nil
        if v, ok := decoded["symbols"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbols = f
            } else {
                symbols = v
            }
            delete(decoded, "symbols")
        }
        
        
        res := <-e.exchange.FetchLeverages(symbols, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) SetPositionMode(hedged bool, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbol interface{} = nil
        if v, ok := decoded["symbol"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbol = f
            } else {
                symbol = v
            }
            delete(decoded, "symbol")
        }
        
        
        res := <-e.exchange.SetPositionMode(hedged, symbol, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) AddMargin(symbol string, amount float64, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.AddMargin(symbol, amount, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) ReduceMargin(symbol string, amount float64, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.ReduceMargin(symbol, amount, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) SetMargin(symbol string, amount float64, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.SetMargin(symbol, amount, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchLongShortRatio(symbol string, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var timeframe interface{} = nil
        if v, ok := decoded["timeframe"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                timeframe = f
            } else {
                timeframe = v
            }
            delete(decoded, "timeframe")
        }
        
        
        res := <-e.exchange.FetchLongShortRatio(symbol, timeframe, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchLongShortRatioHistory(params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbol interface{} = nil
        if v, ok := decoded["symbol"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbol = f
            } else {
                symbol = v
            }
            delete(decoded, "symbol")
        }

        var timeframe interface{} = nil
        if v, ok := decoded["timeframe"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                timeframe = f
            } else {
                timeframe = v
            }
            delete(decoded, "timeframe")
        }

        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            } else {
                since = v
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            } else {
                limit = v
            }
            delete(decoded, "limit")
        }
        
        
        res := <-e.exchange.FetchLongShortRatioHistory(symbol, timeframe, since, limit, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchMarginAdjustmentHistory(params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbol interface{} = nil
        if v, ok := decoded["symbol"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbol = f
            } else {
                symbol = v
            }
            delete(decoded, "symbol")
        }

        var typeVar interface{} = nil
        if v, ok := decoded["typeVar"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                typeVar = f
            } else {
                typeVar = v
            }
            delete(decoded, "typeVar")
        }

        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            } else {
                since = v
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            } else {
                limit = v
            }
            delete(decoded, "limit")
        }
        
        
        res := <-e.exchange.FetchMarginAdjustmentHistory(symbol, typeVar, since, limit, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) SetMarginMode(marginMode string, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbol interface{} = nil
        if v, ok := decoded["symbol"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbol = f
            } else {
                symbol = v
            }
            delete(decoded, "symbol")
        }
        
        
        res := <-e.exchange.SetMarginMode(marginMode, symbol, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchDepositAddressesByNetwork(code string, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.FetchDepositAddressesByNetwork(code, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchOpenInterestHistory(symbol string, timeframe string, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            } else {
                since = v
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            } else {
                limit = v
            }
            delete(decoded, "limit")
        }
        
        
        res := <-e.exchange.FetchOpenInterestHistory(symbol, timeframe, since, limit, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchOpenInterest(symbol string, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.FetchOpenInterest(symbol, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchOpenInterests(params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbols interface{} = nil
        if v, ok := decoded["symbols"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbols = f
            } else {
                symbols = v
            }
            delete(decoded, "symbols")
        }
        
        
        res := <-e.exchange.FetchOpenInterests(symbols, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) SignIn(params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.SignIn(decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchBorrowRate(code string, amount float64, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.FetchBorrowRate(code, amount, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) RepayCrossMargin(code string, amount float64, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.RepayCrossMargin(code, amount, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) RepayIsolatedMargin(symbol string, code string, amount float64, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.RepayIsolatedMargin(symbol, code, amount, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) BorrowCrossMargin(code string, amount float64, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.BorrowCrossMargin(code, amount, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) BorrowIsolatedMargin(symbol string, code string, amount float64, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.BorrowIsolatedMargin(symbol, code, amount, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) BorrowMargin(code string, amount float64, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbol interface{} = nil
        if v, ok := decoded["symbol"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbol = f
            } else {
                symbol = v
            }
            delete(decoded, "symbol")
        }
        
        
        res := <-e.exchange.BorrowMargin(code, amount, symbol, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchOHLCV(symbol string, timeframe string, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            } else {
                since = v
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            } else {
                limit = v
            }
            delete(decoded, "limit")
        }
        
        
        res := <-e.exchange.FetchOHLCV(symbol, timeframe, since, limit, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchL2OrderBook(symbol string, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            } else {
                limit = v
            }
            delete(decoded, "limit")
        }
        
        
        res := <-e.exchange.FetchL2OrderBook(symbol, limit, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) EditOrder(id string, symbol string, typeVar string, side string, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var amount interface{} = nil
        if v, ok := decoded["amount"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                amount = f
            } else {
                amount = v
            }
            delete(decoded, "amount")
        }

        var price interface{} = nil
        if v, ok := decoded["price"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                price = f
            } else {
                price = v
            }
            delete(decoded, "price")
        }
        
        
        res := <-e.exchange.EditOrder(id, symbol, typeVar, side, amount, price, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchPosition(symbol string, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.FetchPosition(symbol, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchPositionsForSymbol(symbol string, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.FetchPositionsForSymbol(symbol, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchPositions(params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbols interface{} = nil
        if v, ok := decoded["symbols"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbols = f
            } else {
                symbols = v
            }
            delete(decoded, "symbols")
        }
        
        
        res := <-e.exchange.FetchPositions(symbols, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchPositionsRisk(params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbols interface{} = nil
        if v, ok := decoded["symbols"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbols = f
            } else {
                symbols = v
            }
            delete(decoded, "symbols")
        }
        
        
        res := <-e.exchange.FetchPositionsRisk(symbols, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchBidsAsks(params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbols interface{} = nil
        if v, ok := decoded["symbols"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbols = f
            } else {
                symbols = v
            }
            delete(decoded, "symbols")
        }
        
        
        res := <-e.exchange.FetchBidsAsks(symbols, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchBorrowInterest(params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var code interface{} = nil
        if v, ok := decoded["code"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                code = f
            } else {
                code = v
            }
            delete(decoded, "code")
        }

        var symbol interface{} = nil
        if v, ok := decoded["symbol"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbol = f
            } else {
                symbol = v
            }
            delete(decoded, "symbol")
        }

        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            } else {
                since = v
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            } else {
                limit = v
            }
            delete(decoded, "limit")
        }
        
        
        res := <-e.exchange.FetchBorrowInterest(code, symbol, since, limit, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchLedger(params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var code interface{} = nil
        if v, ok := decoded["code"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                code = f
            } else {
                code = v
            }
            delete(decoded, "code")
        }

        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            } else {
                since = v
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            } else {
                limit = v
            }
            delete(decoded, "limit")
        }
        
        
        res := <-e.exchange.FetchLedger(code, since, limit, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchLedgerEntry(id string, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var code interface{} = nil
        if v, ok := decoded["code"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                code = f
            } else {
                code = v
            }
            delete(decoded, "code")
        }
        
        
        res := <-e.exchange.FetchLedgerEntry(id, code, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchBalance(params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.FetchBalance(decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchStatus(params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.FetchStatus(decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchTransactionFee(code string, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.FetchTransactionFee(code, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchTransactionFees(params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var codes interface{} = nil
        if v, ok := decoded["codes"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                codes = f
            } else {
                codes = v
            }
            delete(decoded, "codes")
        }
        
        
        res := <-e.exchange.FetchTransactionFees(codes, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchDepositWithdrawFee(code string, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.FetchDepositWithdrawFee(code, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchCrossBorrowRate(code string, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.FetchCrossBorrowRate(code, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchIsolatedBorrowRate(symbol string, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.FetchIsolatedBorrowRate(symbol, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchTicker(symbol string, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.FetchTicker(symbol, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchTickers(params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbols interface{} = nil
        if v, ok := decoded["symbols"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbols = f
            } else {
                symbols = v
            }
            delete(decoded, "symbols")
        }
        
        
        res := <-e.exchange.FetchTickers(symbols, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchMarkPrices(params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbols interface{} = nil
        if v, ok := decoded["symbols"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbols = f
            } else {
                symbols = v
            }
            delete(decoded, "symbols")
        }
        
        
        res := <-e.exchange.FetchMarkPrices(symbols, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchOrderBooks(params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbols interface{} = nil
        if v, ok := decoded["symbols"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbols = f
            } else {
                symbols = v
            }
            delete(decoded, "symbols")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            } else {
                limit = v
            }
            delete(decoded, "limit")
        }
        
        
        res := <-e.exchange.FetchOrderBooks(symbols, limit, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchOrder(id string, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbol interface{} = nil
        if v, ok := decoded["symbol"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbol = f
            } else {
                symbol = v
            }
            delete(decoded, "symbol")
        }
        
        
        res := <-e.exchange.FetchOrder(id, symbol, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) CreateOrder(symbol string, typeVar string, side string, amount float64, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var price interface{} = nil
        if v, ok := decoded["price"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                price = f
            } else {
                price = v
            }
            delete(decoded, "price")
        }
        
        
        res := <-e.exchange.CreateOrder(symbol, typeVar, side, amount, price, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchConvertTrade(id string, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var code interface{} = nil
        if v, ok := decoded["code"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                code = f
            } else {
                code = v
            }
            delete(decoded, "code")
        }
        
        
        res := <-e.exchange.FetchConvertTrade(id, code, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchConvertTradeHistory(params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var code interface{} = nil
        if v, ok := decoded["code"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                code = f
            } else {
                code = v
            }
            delete(decoded, "code")
        }

        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            } else {
                since = v
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            } else {
                limit = v
            }
            delete(decoded, "limit")
        }
        
        
        res := <-e.exchange.FetchConvertTradeHistory(code, since, limit, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchPositionMode(params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbol interface{} = nil
        if v, ok := decoded["symbol"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbol = f
            } else {
                symbol = v
            }
            delete(decoded, "symbol")
        }
        
        
        res := <-e.exchange.FetchPositionMode(symbol, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) CreateTrailingAmountOrder(symbol string, typeVar string, side string, amount float64, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var price interface{} = nil
        if v, ok := decoded["price"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                price = f
            } else {
                price = v
            }
            delete(decoded, "price")
        }

        var trailingAmount interface{} = nil
        if v, ok := decoded["trailingAmount"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                trailingAmount = f
            } else {
                trailingAmount = v
            }
            delete(decoded, "trailingAmount")
        }

        var trailingTriggerPrice interface{} = nil
        if v, ok := decoded["trailingTriggerPrice"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                trailingTriggerPrice = f
            } else {
                trailingTriggerPrice = v
            }
            delete(decoded, "trailingTriggerPrice")
        }
        
        
        res := <-e.exchange.CreateTrailingAmountOrder(symbol, typeVar, side, amount, price, trailingAmount, trailingTriggerPrice, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) CreateTrailingPercentOrder(symbol string, typeVar string, side string, amount float64, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var price interface{} = nil
        if v, ok := decoded["price"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                price = f
            } else {
                price = v
            }
            delete(decoded, "price")
        }

        var trailingPercent interface{} = nil
        if v, ok := decoded["trailingPercent"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                trailingPercent = f
            } else {
                trailingPercent = v
            }
            delete(decoded, "trailingPercent")
        }

        var trailingTriggerPrice interface{} = nil
        if v, ok := decoded["trailingTriggerPrice"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                trailingTriggerPrice = f
            } else {
                trailingTriggerPrice = v
            }
            delete(decoded, "trailingTriggerPrice")
        }
        
        
        res := <-e.exchange.CreateTrailingPercentOrder(symbol, typeVar, side, amount, price, trailingPercent, trailingTriggerPrice, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) CreateMarketOrderWithCost(symbol string, side string, cost float64, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.CreateMarketOrderWithCost(symbol, side, cost, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) CreateMarketBuyOrderWithCost(symbol string, cost float64, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.CreateMarketBuyOrderWithCost(symbol, cost, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) CreateMarketSellOrderWithCost(symbol string, cost float64, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.CreateMarketSellOrderWithCost(symbol, cost, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) CreateTriggerOrder(symbol string, typeVar string, side string, amount float64, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var price interface{} = nil
        if v, ok := decoded["price"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                price = f
            } else {
                price = v
            }
            delete(decoded, "price")
        }

        var triggerPrice interface{} = nil
        if v, ok := decoded["triggerPrice"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                triggerPrice = f
            } else {
                triggerPrice = v
            }
            delete(decoded, "triggerPrice")
        }
        
        
        res := <-e.exchange.CreateTriggerOrder(symbol, typeVar, side, amount, price, triggerPrice, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) CreateStopLossOrder(symbol string, typeVar string, side string, amount float64, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var price interface{} = nil
        if v, ok := decoded["price"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                price = f
            } else {
                price = v
            }
            delete(decoded, "price")
        }

        var stopLossPrice interface{} = nil
        if v, ok := decoded["stopLossPrice"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                stopLossPrice = f
            } else {
                stopLossPrice = v
            }
            delete(decoded, "stopLossPrice")
        }
        
        
        res := <-e.exchange.CreateStopLossOrder(symbol, typeVar, side, amount, price, stopLossPrice, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) CreateTakeProfitOrder(symbol string, typeVar string, side string, amount float64, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var price interface{} = nil
        if v, ok := decoded["price"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                price = f
            } else {
                price = v
            }
            delete(decoded, "price")
        }

        var takeProfitPrice interface{} = nil
        if v, ok := decoded["takeProfitPrice"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                takeProfitPrice = f
            } else {
                takeProfitPrice = v
            }
            delete(decoded, "takeProfitPrice")
        }
        
        
        res := <-e.exchange.CreateTakeProfitOrder(symbol, typeVar, side, amount, price, takeProfitPrice, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) CreateOrderWithTakeProfitAndStopLoss(symbol string, typeVar string, side string, amount float64, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var price interface{} = nil
        if v, ok := decoded["price"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                price = f
            } else {
                price = v
            }
            delete(decoded, "price")
        }

        var takeProfit interface{} = nil
        if v, ok := decoded["takeProfit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                takeProfit = f
            } else {
                takeProfit = v
            }
            delete(decoded, "takeProfit")
        }

        var stopLoss interface{} = nil
        if v, ok := decoded["stopLoss"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                stopLoss = f
            } else {
                stopLoss = v
            }
            delete(decoded, "stopLoss")
        }
        
        
        res := <-e.exchange.CreateOrderWithTakeProfitAndStopLoss(symbol, typeVar, side, amount, price, takeProfit, stopLoss, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) CancelOrder(id string, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbol interface{} = nil
        if v, ok := decoded["symbol"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbol = f
            } else {
                symbol = v
            }
            delete(decoded, "symbol")
        }
        
        
        res := <-e.exchange.CancelOrder(id, symbol, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) CancelAllOrders(params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbol interface{} = nil
        if v, ok := decoded["symbol"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbol = f
            } else {
                symbol = v
            }
            delete(decoded, "symbol")
        }
        
        
        res := <-e.exchange.CancelAllOrders(symbol, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchOrders(params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbol interface{} = nil
        if v, ok := decoded["symbol"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbol = f
            } else {
                symbol = v
            }
            delete(decoded, "symbol")
        }

        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            } else {
                since = v
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            } else {
                limit = v
            }
            delete(decoded, "limit")
        }
        
        
        res := <-e.exchange.FetchOrders(symbol, since, limit, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchOrderTrades(id string, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbol interface{} = nil
        if v, ok := decoded["symbol"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbol = f
            } else {
                symbol = v
            }
            delete(decoded, "symbol")
        }

        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            } else {
                since = v
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            } else {
                limit = v
            }
            delete(decoded, "limit")
        }
        
        
        res := <-e.exchange.FetchOrderTrades(id, symbol, since, limit, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchOpenOrders(params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbol interface{} = nil
        if v, ok := decoded["symbol"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbol = f
            } else {
                symbol = v
            }
            delete(decoded, "symbol")
        }

        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            } else {
                since = v
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            } else {
                limit = v
            }
            delete(decoded, "limit")
        }
        
        
        res := <-e.exchange.FetchOpenOrders(symbol, since, limit, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchClosedOrders(params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbol interface{} = nil
        if v, ok := decoded["symbol"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbol = f
            } else {
                symbol = v
            }
            delete(decoded, "symbol")
        }

        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            } else {
                since = v
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            } else {
                limit = v
            }
            delete(decoded, "limit")
        }
        
        
        res := <-e.exchange.FetchClosedOrders(symbol, since, limit, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchCanceledAndClosedOrders(params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbol interface{} = nil
        if v, ok := decoded["symbol"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbol = f
            } else {
                symbol = v
            }
            delete(decoded, "symbol")
        }

        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            } else {
                since = v
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            } else {
                limit = v
            }
            delete(decoded, "limit")
        }
        
        
        res := <-e.exchange.FetchCanceledAndClosedOrders(symbol, since, limit, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchMyTrades(params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbol interface{} = nil
        if v, ok := decoded["symbol"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbol = f
            } else {
                symbol = v
            }
            delete(decoded, "symbol")
        }

        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            } else {
                since = v
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            } else {
                limit = v
            }
            delete(decoded, "limit")
        }
        
        
        res := <-e.exchange.FetchMyTrades(symbol, since, limit, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchMyLiquidations(params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbol interface{} = nil
        if v, ok := decoded["symbol"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbol = f
            } else {
                symbol = v
            }
            delete(decoded, "symbol")
        }

        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            } else {
                since = v
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            } else {
                limit = v
            }
            delete(decoded, "limit")
        }
        
        
        res := <-e.exchange.FetchMyLiquidations(symbol, since, limit, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchLiquidations(symbol string, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            } else {
                since = v
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            } else {
                limit = v
            }
            delete(decoded, "limit")
        }
        
        
        res := <-e.exchange.FetchLiquidations(symbol, since, limit, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchGreeks(symbol string, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.FetchGreeks(symbol, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchOptionChain(code string, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.FetchOptionChain(code, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchOption(symbol string, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.FetchOption(symbol, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchConvertQuote(fromCode string, toCode string, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var amount interface{} = nil
        if v, ok := decoded["amount"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                amount = f
            } else {
                amount = v
            }
            delete(decoded, "amount")
        }
        
        
        res := <-e.exchange.FetchConvertQuote(fromCode, toCode, amount, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchDepositsWithdrawals(params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var code interface{} = nil
        if v, ok := decoded["code"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                code = f
            } else {
                code = v
            }
            delete(decoded, "code")
        }

        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            } else {
                since = v
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            } else {
                limit = v
            }
            delete(decoded, "limit")
        }
        
        
        res := <-e.exchange.FetchDepositsWithdrawals(code, since, limit, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchDeposits(params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var code interface{} = nil
        if v, ok := decoded["code"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                code = f
            } else {
                code = v
            }
            delete(decoded, "code")
        }

        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            } else {
                since = v
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            } else {
                limit = v
            }
            delete(decoded, "limit")
        }
        
        
        res := <-e.exchange.FetchDeposits(code, since, limit, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchWithdrawals(params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var code interface{} = nil
        if v, ok := decoded["code"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                code = f
            } else {
                code = v
            }
            delete(decoded, "code")
        }

        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            } else {
                since = v
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            } else {
                limit = v
            }
            delete(decoded, "limit")
        }
        
        
        res := <-e.exchange.FetchWithdrawals(code, since, limit, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchFundingRateHistory(params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbol interface{} = nil
        if v, ok := decoded["symbol"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbol = f
            } else {
                symbol = v
            }
            delete(decoded, "symbol")
        }

        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            } else {
                since = v
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            } else {
                limit = v
            }
            delete(decoded, "limit")
        }
        
        
        res := <-e.exchange.FetchFundingRateHistory(symbol, since, limit, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchFundingHistory(params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbol interface{} = nil
        if v, ok := decoded["symbol"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbol = f
            } else {
                symbol = v
            }
            delete(decoded, "symbol")
        }

        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            } else {
                since = v
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            } else {
                limit = v
            }
            delete(decoded, "limit")
        }
        
        
        res := <-e.exchange.FetchFundingHistory(symbol, since, limit, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) ClosePosition(symbol string, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var side interface{} = nil
        if v, ok := decoded["side"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                side = f
            } else {
                side = v
            }
            delete(decoded, "side")
        }
        
        
        res := <-e.exchange.ClosePosition(symbol, side, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) CloseAllPositions(params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.CloseAllPositions(decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchL3OrderBook(symbol string, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            } else {
                limit = v
            }
            delete(decoded, "limit")
        }
        
        
        res := <-e.exchange.FetchL3OrderBook(symbol, limit, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchDepositAddress(code string, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.FetchDepositAddress(code, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) CreateLimitOrder(symbol string, side string, amount float64, price float64, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.CreateLimitOrder(symbol, side, amount, price, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) CreateMarketOrder(symbol string, side string, amount float64, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var price interface{} = nil
        if v, ok := decoded["price"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                price = f
            } else {
                price = v
            }
            delete(decoded, "price")
        }
        
        
        res := <-e.exchange.CreateMarketOrder(symbol, side, amount, price, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) CreateLimitBuyOrder(symbol string, amount float64, price float64, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.CreateLimitBuyOrder(symbol, amount, price, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) CreateLimitSellOrder(symbol string, amount float64, price float64, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.CreateLimitSellOrder(symbol, amount, price, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) CreateMarketBuyOrder(symbol string, amount float64, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.CreateMarketBuyOrder(symbol, amount, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) CreateMarketSellOrder(symbol string, amount float64, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.CreateMarketSellOrder(symbol, amount, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchMarketLeverageTiers(symbol string, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.FetchMarketLeverageTiers(symbol, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) CreatePostOnlyOrder(symbol string, typeVar string, side string, amount float64, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var price interface{} = nil
        if v, ok := decoded["price"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                price = f
            } else {
                price = v
            }
            delete(decoded, "price")
        }
        
        
        res := <-e.exchange.CreatePostOnlyOrder(symbol, typeVar, side, amount, price, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) CreateReduceOnlyOrder(symbol string, typeVar string, side string, amount float64, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var price interface{} = nil
        if v, ok := decoded["price"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                price = f
            } else {
                price = v
            }
            delete(decoded, "price")
        }
        
        
        res := <-e.exchange.CreateReduceOnlyOrder(symbol, typeVar, side, amount, price, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) CreateStopOrder(symbol string, typeVar string, side string, amount float64, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var price interface{} = nil
        if v, ok := decoded["price"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                price = f
            } else {
                price = v
            }
            delete(decoded, "price")
        }

        var triggerPrice interface{} = nil
        if v, ok := decoded["triggerPrice"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                triggerPrice = f
            } else {
                triggerPrice = v
            }
            delete(decoded, "triggerPrice")
        }
        
        
        res := <-e.exchange.CreateStopOrder(symbol, typeVar, side, amount, price, triggerPrice, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) CreateStopLimitOrder(symbol string, side string, amount float64, price float64, triggerPrice float64, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.CreateStopLimitOrder(symbol, side, amount, price, triggerPrice, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) CreateStopMarketOrder(symbol string, side string, amount float64, triggerPrice float64, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.CreateStopMarketOrder(symbol, side, amount, triggerPrice, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchLastPrices(params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbols interface{} = nil
        if v, ok := decoded["symbols"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbols = f
            } else {
                symbols = v
            }
            delete(decoded, "symbols")
        }
        
        
        res := <-e.exchange.FetchLastPrices(symbols, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchTradingFees(params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.FetchTradingFees(decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchTradingFee(symbol string, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.FetchTradingFee(symbol, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchConvertCurrencies(params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.FetchConvertCurrencies(decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchFundingRate(symbol string, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.FetchFundingRate(symbol, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchFundingInterval(symbol string, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        
        res := <-e.exchange.FetchFundingInterval(symbol, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchMarkOHLCV(symbol string, timeframe string, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            } else {
                since = v
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            } else {
                limit = v
            }
            delete(decoded, "limit")
        }
        
        
        res := <-e.exchange.FetchMarkOHLCV(symbol, timeframe, since, limit, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchIndexOHLCV(symbol string, timeframe string, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            } else {
                since = v
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            } else {
                limit = v
            }
            delete(decoded, "limit")
        }
        
        
        res := <-e.exchange.FetchIndexOHLCV(symbol, timeframe, since, limit, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchPremiumIndexOHLCV(symbol string, timeframe string, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            } else {
                since = v
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            } else {
                limit = v
            }
            delete(decoded, "limit")
        }
        
        
        res := <-e.exchange.FetchPremiumIndexOHLCV(symbol, timeframe, since, limit, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchTransactions(params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var code interface{} = nil
        if v, ok := decoded["code"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                code = f
            } else {
                code = v
            }
            delete(decoded, "code")
        }

        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            } else {
                since = v
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            } else {
                limit = v
            }
            delete(decoded, "limit")
        }
        
        
        res := <-e.exchange.FetchTransactions(code, since, limit, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchPositionHistory(symbol string, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            } else {
                since = v
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            } else {
                limit = v
            }
            delete(decoded, "limit")
        }
        
        
        res := <-e.exchange.FetchPositionHistory(symbol, since, limit, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchPositionsHistory(params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbols interface{} = nil
        if v, ok := decoded["symbols"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbols = f
            } else {
                symbols = v
            }
            delete(decoded, "symbols")
        }

        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            } else {
                since = v
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            } else {
                limit = v
            }
            delete(decoded, "limit")
        }
        
        
        res := <-e.exchange.FetchPositionsHistory(symbols, since, limit, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchTransfer(id string, params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var code interface{} = nil
        if v, ok := decoded["code"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                code = f
            } else {
                code = v
            }
            delete(decoded, "code")
        }
        
        
        res := <-e.exchange.FetchTransfer(id, code, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }

    func (e *CCXTGoExchange) FetchTransfers(params []byte) ([]byte, error) {
            
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var code interface{} = nil
        if v, ok := decoded["code"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                code = f
            } else {
                code = v
            }
            delete(decoded, "code")
        }

        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            } else {
                since = v
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            } else {
                limit = v
            }
            delete(decoded, "limit")
        }
        
        
        res := <-e.exchange.FetchTransfers(code, since, limit, decoded)
        switch v := res.(type) {
        case string:
            if strings.HasPrefix(v, "panic:") {
                return nil, fmt.Errorf("%s", v)
            }
        case error:
            return nil, v
        }
        sanitised := sanitise(res) // deep copy; no in-place mutation
        b, err := json.Marshal(sanitised)
        if err != nil {
            return nil, err
        }
        return b, nil
        
    }
