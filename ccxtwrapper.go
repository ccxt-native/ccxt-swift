// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

package ccxt

import (
	"C"
	"encoding/json"
	"fmt"
	"math"
	"regexp"
	"strings"
	   ccxt "github.com/ccxt/ccxt/go/v4"
)
type CCXTGoExchange struct {
	exchange ccxt.ICoreExchange
}

func NewExchange(exchangeName string, configJson string) *CCXTGoExchange {
	// First, remove the outer quotes if they exist
	configJson = strings.Trim(configJson, "\"")

	// Convert JavaScript object syntax to valid JSON:
	// 1. Replace single quotes with double quotes
	configJson = strings.ReplaceAll(configJson, "'", "\"")
	// 2. Add double quotes to unquoted keys
	configJson = regexp.MustCompile(`(\w+):`).ReplaceAllString(configJson, "\"$1\":")

	var config map[string]interface{}
	if err := json.Unmarshal([]byte(configJson), &config); err != nil {
		fmt.Printf("Go: Failed to parse configJson: %v\nInput was: %s\nProcessed to: %s\n", err, configJson, configJson)
		return nil
	}
	var inst, ok = ccxt.DynamicallyCreateInstance(exchangeName, config)
	if !ok {
		return nil
	}

	return &CCXTGoExchange{exchange: inst}
}

func parseJSON(input string) []byte {
	var intermediate string
	if err := json.Unmarshal([]byte(input), &intermediate); err == nil {
		// Input was a double-quoted JSON string â€” unwrap it
		input = intermediate
	}

	var anything interface{}
	if err := json.Unmarshal([]byte(input), &anything); err != nil {
		// Return a consistent error message as JSON
		errorObj := map[string]string{"error": "Invalid JSON"}
		b, _ := json.Marshal(errorObj)
		return b
	}

	b, _ := json.Marshal(anything)
	return b
}

func sanitise(v interface{}) interface{} {
	switch x := v.(type) {
	case float64:
		if math.IsNaN(x) || math.IsInf(x, 0) {
			return nil
		}
		return x
	case map[string]interface{}:
		for k, vv := range x {
			x[k] = sanitise(vv)
		}
		return x
	case []interface{}:
		for i, vv := range x {
			x[i] = sanitise(vv)
		}
		return x
	default:
		return v
	}
}

// ------------------------------------------------------------------------

// ########################################################################
// ########################################################################
// ########################################################################
// ########################################################################
// ########                        ########                        ########
// ########                        ########                        ########
// ########                        ########                        ########
// ########                        ########                        ########
// ########        ########################        ########################
// ########        ########################        ########################
// ########        ########################        ########################
// ########        ########################        ########################
// ########                        ########                        ########
// ########                        ########                        ########
// ########                        ########                        ########
// ########                        ########                        ########
// ########################################################################
// ########################################################################
// ########################################################################
// ########################################################################
// ########        ########        ########                        ########
// ########        ########        ########                        ########
// ########        ########        ########                        ########
// ########        ########        ########                        ########
// ################        ########################        ################
// ################        ########################        ################
// ################        ########################        ################
// ################        ########################        ################
// ########        ########        ################        ################
// ########        ########        ################        ################
// ########        ########        ################        ################
// ########        ########        ################        ################
// ########################################################################
// ########################################################################
// ########################################################################
// ########################################################################

// ------------------------------------------------------------------------
// METHODS BELOW THIS LINE ARE TRANSPILED


    func (e *CCXTGoExchange) LoadMarkets(reload bool, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.LoadMarkets(reload, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchCurrencies(params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.FetchCurrencies(decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchMarkets(params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.FetchMarkets(decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchAccounts(params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.FetchAccounts(decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchTrades(symbol string, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            }
            delete(decoded, "limit")
        }
        
        res := <-e.exchange.FetchTrades(symbol, since, limit, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchDepositAddresses(params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var codes interface{} = nil
        if v, ok := decoded["codes"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                codes = f
            }
            delete(decoded, "codes")
        }
        
        res := <-e.exchange.FetchDepositAddresses(codes, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchOrderBook(symbol string, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            }
            delete(decoded, "limit")
        }
        
        res := <-e.exchange.FetchOrderBook(symbol, limit, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchMarginMode(symbol string, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.FetchMarginMode(symbol, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchMarginModes(params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbols interface{} = nil
        if v, ok := decoded["symbols"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbols = f
            }
            delete(decoded, "symbols")
        }
        
        res := <-e.exchange.FetchMarginModes(symbols, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchTime(params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.FetchTime(decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchTradingLimits(params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbols interface{} = nil
        if v, ok := decoded["symbols"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbols = f
            }
            delete(decoded, "symbols")
        }
        
        res := <-e.exchange.FetchTradingLimits(symbols, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchCrossBorrowRates(params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.FetchCrossBorrowRates(decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchIsolatedBorrowRates(params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.FetchIsolatedBorrowRates(decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchLeverageTiers(params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbols interface{} = nil
        if v, ok := decoded["symbols"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbols = f
            }
            delete(decoded, "symbols")
        }
        
        res := <-e.exchange.FetchLeverageTiers(symbols, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchFundingRates(params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbols interface{} = nil
        if v, ok := decoded["symbols"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbols = f
            }
            delete(decoded, "symbols")
        }
        
        res := <-e.exchange.FetchFundingRates(symbols, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchFundingIntervals(params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbols interface{} = nil
        if v, ok := decoded["symbols"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbols = f
            }
            delete(decoded, "symbols")
        }
        
        res := <-e.exchange.FetchFundingIntervals(symbols, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) Transfer(code string, amount float64, fromAccount string, toAccount string, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.Transfer(code, amount, fromAccount, toAccount, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) Withdraw(code string, amount float64, address string, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var tag interface{} = nil
        if v, ok := decoded["tag"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                tag = f
            }
            delete(decoded, "tag")
        }
        
        res := <-e.exchange.Withdraw(code, amount, address, tag, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) CreateDepositAddress(code string, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.CreateDepositAddress(code, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) SetLeverage(leverage int, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbol interface{} = nil
        if v, ok := decoded["symbol"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbol = f
            }
            delete(decoded, "symbol")
        }
        
        res := <-e.exchange.SetLeverage(leverage, symbol, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchLeverage(symbol string, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.FetchLeverage(symbol, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchLeverages(params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbols interface{} = nil
        if v, ok := decoded["symbols"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbols = f
            }
            delete(decoded, "symbols")
        }
        
        res := <-e.exchange.FetchLeverages(symbols, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) SetPositionMode(hedged bool, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbol interface{} = nil
        if v, ok := decoded["symbol"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbol = f
            }
            delete(decoded, "symbol")
        }
        
        res := <-e.exchange.SetPositionMode(hedged, symbol, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) AddMargin(symbol string, amount float64, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.AddMargin(symbol, amount, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) ReduceMargin(symbol string, amount float64, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.ReduceMargin(symbol, amount, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) SetMargin(symbol string, amount float64, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.SetMargin(symbol, amount, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchLongShortRatio(symbol string, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var timeframe interface{} = nil
        if v, ok := decoded["timeframe"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                timeframe = f
            }
            delete(decoded, "timeframe")
        }
        
        res := <-e.exchange.FetchLongShortRatio(symbol, timeframe, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchLongShortRatioHistory(params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbol interface{} = nil
        if v, ok := decoded["symbol"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbol = f
            }
            delete(decoded, "symbol")
        }

        var timeframe interface{} = nil
        if v, ok := decoded["timeframe"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                timeframe = f
            }
            delete(decoded, "timeframe")
        }

        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            }
            delete(decoded, "limit")
        }
        
        res := <-e.exchange.FetchLongShortRatioHistory(symbol, timeframe, since, limit, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchMarginAdjustmentHistory(params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbol interface{} = nil
        if v, ok := decoded["symbol"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbol = f
            }
            delete(decoded, "symbol")
        }

        var typeVar interface{} = nil
        if v, ok := decoded["typeVar"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                typeVar = f
            }
            delete(decoded, "typeVar")
        }

        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            }
            delete(decoded, "limit")
        }
        
        res := <-e.exchange.FetchMarginAdjustmentHistory(symbol, typeVar, since, limit, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) SetMarginMode(marginMode string, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbol interface{} = nil
        if v, ok := decoded["symbol"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbol = f
            }
            delete(decoded, "symbol")
        }
        
        res := <-e.exchange.SetMarginMode(marginMode, symbol, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchDepositAddressesByNetwork(code string, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.FetchDepositAddressesByNetwork(code, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchOpenInterestHistory(symbol string, timeframe string, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            }
            delete(decoded, "limit")
        }
        
        res := <-e.exchange.FetchOpenInterestHistory(symbol, timeframe, since, limit, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchOpenInterest(symbol string, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.FetchOpenInterest(symbol, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchOpenInterests(params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbols interface{} = nil
        if v, ok := decoded["symbols"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbols = f
            }
            delete(decoded, "symbols")
        }
        
        res := <-e.exchange.FetchOpenInterests(symbols, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) SignIn(params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.SignIn(decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchBorrowRate(code string, amount float64, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.FetchBorrowRate(code, amount, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) RepayCrossMargin(code string, amount float64, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.RepayCrossMargin(code, amount, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) RepayIsolatedMargin(symbol string, code string, amount float64, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.RepayIsolatedMargin(symbol, code, amount, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) BorrowCrossMargin(code string, amount float64, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.BorrowCrossMargin(code, amount, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) BorrowIsolatedMargin(symbol string, code string, amount float64, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.BorrowIsolatedMargin(symbol, code, amount, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) BorrowMargin(code string, amount float64, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbol interface{} = nil
        if v, ok := decoded["symbol"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbol = f
            }
            delete(decoded, "symbol")
        }
        
        res := <-e.exchange.BorrowMargin(code, amount, symbol, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchOHLCV(symbol string, timeframe []byte, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            }
            delete(decoded, "limit")
        }
        
        res := <-e.exchange.FetchOHLCV(symbol, timeframe, since, limit, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchL2OrderBook(symbol string, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            }
            delete(decoded, "limit")
        }
        
        res := <-e.exchange.FetchL2OrderBook(symbol, limit, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) EditOrder(id string, symbol string, typeVar string, side string, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var amount interface{} = nil
        if v, ok := decoded["amount"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                amount = f
            }
            delete(decoded, "amount")
        }

        var price interface{} = nil
        if v, ok := decoded["price"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                price = f
            }
            delete(decoded, "price")
        }
        
        res := <-e.exchange.EditOrder(id, symbol, typeVar, side, amount, price, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchPosition(symbol string, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.FetchPosition(symbol, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchPositionsForSymbol(symbol string, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.FetchPositionsForSymbol(symbol, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchPositions(params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbols interface{} = nil
        if v, ok := decoded["symbols"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbols = f
            }
            delete(decoded, "symbols")
        }
        
        res := <-e.exchange.FetchPositions(symbols, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchPositionsRisk(params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbols interface{} = nil
        if v, ok := decoded["symbols"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbols = f
            }
            delete(decoded, "symbols")
        }
        
        res := <-e.exchange.FetchPositionsRisk(symbols, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchBidsAsks(params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbols interface{} = nil
        if v, ok := decoded["symbols"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbols = f
            }
            delete(decoded, "symbols")
        }
        
        res := <-e.exchange.FetchBidsAsks(symbols, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchBorrowInterest(params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var code interface{} = nil
        if v, ok := decoded["code"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                code = f
            }
            delete(decoded, "code")
        }

        var symbol interface{} = nil
        if v, ok := decoded["symbol"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbol = f
            }
            delete(decoded, "symbol")
        }

        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            }
            delete(decoded, "limit")
        }
        
        res := <-e.exchange.FetchBorrowInterest(code, symbol, since, limit, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchLedger(params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var code interface{} = nil
        if v, ok := decoded["code"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                code = f
            }
            delete(decoded, "code")
        }

        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            }
            delete(decoded, "limit")
        }
        
        res := <-e.exchange.FetchLedger(code, since, limit, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchLedgerEntry(id string, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var code interface{} = nil
        if v, ok := decoded["code"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                code = f
            }
            delete(decoded, "code")
        }
        
        res := <-e.exchange.FetchLedgerEntry(id, code, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchBalance(params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.FetchBalance(decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchStatus(params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.FetchStatus(decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchTransactionFee(code string, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.FetchTransactionFee(code, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchTransactionFees(params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var codes interface{} = nil
        if v, ok := decoded["codes"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                codes = f
            }
            delete(decoded, "codes")
        }
        
        res := <-e.exchange.FetchTransactionFees(codes, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchDepositWithdrawFees(params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var codes interface{} = nil
        if v, ok := decoded["codes"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                codes = f
            }
            delete(decoded, "codes")
        }
        
        res := <-e.exchange.FetchDepositWithdrawFees(codes, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchDepositWithdrawFee(code string, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.FetchDepositWithdrawFee(code, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchCrossBorrowRate(code string, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.FetchCrossBorrowRate(code, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchIsolatedBorrowRate(symbol string, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.FetchIsolatedBorrowRate(symbol, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchTicker(symbol string, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.FetchTicker(symbol, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchTickers(params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbols interface{} = nil
        if v, ok := decoded["symbols"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbols = f
            }
            delete(decoded, "symbols")
        }
        
        res := <-e.exchange.FetchTickers(symbols, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchMarkPrices(params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbols interface{} = nil
        if v, ok := decoded["symbols"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbols = f
            }
            delete(decoded, "symbols")
        }
        
        res := <-e.exchange.FetchMarkPrices(symbols, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchOrderBooks(params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbols interface{} = nil
        if v, ok := decoded["symbols"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbols = f
            }
            delete(decoded, "symbols")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            }
            delete(decoded, "limit")
        }
        
        res := <-e.exchange.FetchOrderBooks(symbols, limit, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchOrder(id string, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbol interface{} = nil
        if v, ok := decoded["symbol"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbol = f
            }
            delete(decoded, "symbol")
        }
        
        res := <-e.exchange.FetchOrder(id, symbol, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) CreateOrder(symbol string, typeVar string, side string, amount float64, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var price interface{} = nil
        if v, ok := decoded["price"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                price = f
            }
            delete(decoded, "price")
        }
        
        res := <-e.exchange.CreateOrder(symbol, typeVar, side, amount, price, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchConvertTrade(id string, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var code interface{} = nil
        if v, ok := decoded["code"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                code = f
            }
            delete(decoded, "code")
        }
        
        res := <-e.exchange.FetchConvertTrade(id, code, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchConvertTradeHistory(params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var code interface{} = nil
        if v, ok := decoded["code"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                code = f
            }
            delete(decoded, "code")
        }

        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            }
            delete(decoded, "limit")
        }
        
        res := <-e.exchange.FetchConvertTradeHistory(code, since, limit, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchPositionMode(params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbol interface{} = nil
        if v, ok := decoded["symbol"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbol = f
            }
            delete(decoded, "symbol")
        }
        
        res := <-e.exchange.FetchPositionMode(symbol, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) CreateTrailingAmountOrder(symbol string, typeVar string, side string, amount float64, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var price interface{} = nil
        if v, ok := decoded["price"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                price = f
            }
            delete(decoded, "price")
        }

        var trailingAmount interface{} = nil
        if v, ok := decoded["trailingAmount"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                trailingAmount = f
            }
            delete(decoded, "trailingAmount")
        }

        var trailingTriggerPrice interface{} = nil
        if v, ok := decoded["trailingTriggerPrice"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                trailingTriggerPrice = f
            }
            delete(decoded, "trailingTriggerPrice")
        }
        
        res := <-e.exchange.CreateTrailingAmountOrder(symbol, typeVar, side, amount, price, trailingAmount, trailingTriggerPrice, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) CreateTrailingPercentOrder(symbol string, typeVar string, side string, amount float64, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var price interface{} = nil
        if v, ok := decoded["price"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                price = f
            }
            delete(decoded, "price")
        }

        var trailingPercent interface{} = nil
        if v, ok := decoded["trailingPercent"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                trailingPercent = f
            }
            delete(decoded, "trailingPercent")
        }

        var trailingTriggerPrice interface{} = nil
        if v, ok := decoded["trailingTriggerPrice"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                trailingTriggerPrice = f
            }
            delete(decoded, "trailingTriggerPrice")
        }
        
        res := <-e.exchange.CreateTrailingPercentOrder(symbol, typeVar, side, amount, price, trailingPercent, trailingTriggerPrice, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) CreateMarketOrderWithCost(symbol string, side string, cost float64, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.CreateMarketOrderWithCost(symbol, side, cost, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) CreateMarketBuyOrderWithCost(symbol string, cost float64, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.CreateMarketBuyOrderWithCost(symbol, cost, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) CreateMarketSellOrderWithCost(symbol string, cost float64, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.CreateMarketSellOrderWithCost(symbol, cost, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) CreateTriggerOrder(symbol string, typeVar string, side string, amount float64, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var price interface{} = nil
        if v, ok := decoded["price"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                price = f
            }
            delete(decoded, "price")
        }

        var triggerPrice interface{} = nil
        if v, ok := decoded["triggerPrice"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                triggerPrice = f
            }
            delete(decoded, "triggerPrice")
        }
        
        res := <-e.exchange.CreateTriggerOrder(symbol, typeVar, side, amount, price, triggerPrice, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) CreateStopLossOrder(symbol string, typeVar string, side string, amount float64, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var price interface{} = nil
        if v, ok := decoded["price"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                price = f
            }
            delete(decoded, "price")
        }

        var stopLossPrice interface{} = nil
        if v, ok := decoded["stopLossPrice"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                stopLossPrice = f
            }
            delete(decoded, "stopLossPrice")
        }
        
        res := <-e.exchange.CreateStopLossOrder(symbol, typeVar, side, amount, price, stopLossPrice, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) CreateTakeProfitOrder(symbol string, typeVar string, side string, amount float64, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var price interface{} = nil
        if v, ok := decoded["price"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                price = f
            }
            delete(decoded, "price")
        }

        var takeProfitPrice interface{} = nil
        if v, ok := decoded["takeProfitPrice"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                takeProfitPrice = f
            }
            delete(decoded, "takeProfitPrice")
        }
        
        res := <-e.exchange.CreateTakeProfitOrder(symbol, typeVar, side, amount, price, takeProfitPrice, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) CreateOrderWithTakeProfitAndStopLoss(symbol string, typeVar string, side string, amount float64, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var price interface{} = nil
        if v, ok := decoded["price"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                price = f
            }
            delete(decoded, "price")
        }

        var takeProfit interface{} = nil
        if v, ok := decoded["takeProfit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                takeProfit = f
            }
            delete(decoded, "takeProfit")
        }

        var stopLoss interface{} = nil
        if v, ok := decoded["stopLoss"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                stopLoss = f
            }
            delete(decoded, "stopLoss")
        }
        
        res := <-e.exchange.CreateOrderWithTakeProfitAndStopLoss(symbol, typeVar, side, amount, price, takeProfit, stopLoss, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) CancelOrder(id string, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbol interface{} = nil
        if v, ok := decoded["symbol"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbol = f
            }
            delete(decoded, "symbol")
        }
        
        res := <-e.exchange.CancelOrder(id, symbol, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) CancelAllOrders(params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbol interface{} = nil
        if v, ok := decoded["symbol"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbol = f
            }
            delete(decoded, "symbol")
        }
        
        res := <-e.exchange.CancelAllOrders(symbol, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchOrders(params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbol interface{} = nil
        if v, ok := decoded["symbol"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbol = f
            }
            delete(decoded, "symbol")
        }

        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            }
            delete(decoded, "limit")
        }
        
        res := <-e.exchange.FetchOrders(symbol, since, limit, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchOrderTrades(id string, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbol interface{} = nil
        if v, ok := decoded["symbol"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbol = f
            }
            delete(decoded, "symbol")
        }

        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            }
            delete(decoded, "limit")
        }
        
        res := <-e.exchange.FetchOrderTrades(id, symbol, since, limit, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchOpenOrders(params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbol interface{} = nil
        if v, ok := decoded["symbol"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbol = f
            }
            delete(decoded, "symbol")
        }

        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            }
            delete(decoded, "limit")
        }
        
        res := <-e.exchange.FetchOpenOrders(symbol, since, limit, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchClosedOrders(params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbol interface{} = nil
        if v, ok := decoded["symbol"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbol = f
            }
            delete(decoded, "symbol")
        }

        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            }
            delete(decoded, "limit")
        }
        
        res := <-e.exchange.FetchClosedOrders(symbol, since, limit, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchCanceledAndClosedOrders(params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbol interface{} = nil
        if v, ok := decoded["symbol"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbol = f
            }
            delete(decoded, "symbol")
        }

        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            }
            delete(decoded, "limit")
        }
        
        res := <-e.exchange.FetchCanceledAndClosedOrders(symbol, since, limit, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchMyTrades(params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbol interface{} = nil
        if v, ok := decoded["symbol"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbol = f
            }
            delete(decoded, "symbol")
        }

        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            }
            delete(decoded, "limit")
        }
        
        res := <-e.exchange.FetchMyTrades(symbol, since, limit, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchMyLiquidations(params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbol interface{} = nil
        if v, ok := decoded["symbol"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbol = f
            }
            delete(decoded, "symbol")
        }

        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            }
            delete(decoded, "limit")
        }
        
        res := <-e.exchange.FetchMyLiquidations(symbol, since, limit, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchLiquidations(symbol string, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            }
            delete(decoded, "limit")
        }
        
        res := <-e.exchange.FetchLiquidations(symbol, since, limit, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchGreeks(symbol string, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.FetchGreeks(symbol, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchOptionChain(code string, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.FetchOptionChain(code, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchOption(symbol string, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.FetchOption(symbol, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchConvertQuote(fromCode string, toCode string, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var amount interface{} = nil
        if v, ok := decoded["amount"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                amount = f
            }
            delete(decoded, "amount")
        }
        
        res := <-e.exchange.FetchConvertQuote(fromCode, toCode, amount, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchDepositsWithdrawals(params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var code interface{} = nil
        if v, ok := decoded["code"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                code = f
            }
            delete(decoded, "code")
        }

        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            }
            delete(decoded, "limit")
        }
        
        res := <-e.exchange.FetchDepositsWithdrawals(code, since, limit, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchDeposits(params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var code interface{} = nil
        if v, ok := decoded["code"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                code = f
            }
            delete(decoded, "code")
        }

        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            }
            delete(decoded, "limit")
        }
        
        res := <-e.exchange.FetchDeposits(code, since, limit, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchWithdrawals(params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var code interface{} = nil
        if v, ok := decoded["code"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                code = f
            }
            delete(decoded, "code")
        }

        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            }
            delete(decoded, "limit")
        }
        
        res := <-e.exchange.FetchWithdrawals(code, since, limit, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchFundingRateHistory(params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbol interface{} = nil
        if v, ok := decoded["symbol"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbol = f
            }
            delete(decoded, "symbol")
        }

        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            }
            delete(decoded, "limit")
        }
        
        res := <-e.exchange.FetchFundingRateHistory(symbol, since, limit, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchFundingHistory(params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbol interface{} = nil
        if v, ok := decoded["symbol"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbol = f
            }
            delete(decoded, "symbol")
        }

        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            }
            delete(decoded, "limit")
        }
        
        res := <-e.exchange.FetchFundingHistory(symbol, since, limit, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) ClosePosition(symbol string, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var side interface{} = nil
        if v, ok := decoded["side"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                side = f
            }
            delete(decoded, "side")
        }
        
        res := <-e.exchange.ClosePosition(symbol, side, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) CloseAllPositions(params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.CloseAllPositions(decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchL3OrderBook(symbol string, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            }
            delete(decoded, "limit")
        }
        
        res := <-e.exchange.FetchL3OrderBook(symbol, limit, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchDepositAddress(code string, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.FetchDepositAddress(code, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) CreateLimitOrder(symbol string, side string, amount float64, price float64, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.CreateLimitOrder(symbol, side, amount, price, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) CreateMarketOrder(symbol string, side string, amount float64, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var price interface{} = nil
        if v, ok := decoded["price"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                price = f
            }
            delete(decoded, "price")
        }
        
        res := <-e.exchange.CreateMarketOrder(symbol, side, amount, price, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) CreateLimitBuyOrder(symbol string, amount float64, price float64, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.CreateLimitBuyOrder(symbol, amount, price, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) CreateLimitSellOrder(symbol string, amount float64, price float64, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.CreateLimitSellOrder(symbol, amount, price, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) CreateMarketBuyOrder(symbol string, amount float64, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.CreateMarketBuyOrder(symbol, amount, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) CreateMarketSellOrder(symbol string, amount float64, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.CreateMarketSellOrder(symbol, amount, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchMarketLeverageTiers(symbol string, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.FetchMarketLeverageTiers(symbol, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) CreatePostOnlyOrder(symbol string, typeVar string, side string, amount float64, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var price interface{} = nil
        if v, ok := decoded["price"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                price = f
            }
            delete(decoded, "price")
        }
        
        res := <-e.exchange.CreatePostOnlyOrder(symbol, typeVar, side, amount, price, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) CreateReduceOnlyOrder(symbol string, typeVar string, side string, amount float64, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var price interface{} = nil
        if v, ok := decoded["price"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                price = f
            }
            delete(decoded, "price")
        }
        
        res := <-e.exchange.CreateReduceOnlyOrder(symbol, typeVar, side, amount, price, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) CreateStopOrder(symbol string, typeVar string, side string, amount float64, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var price interface{} = nil
        if v, ok := decoded["price"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                price = f
            }
            delete(decoded, "price")
        }

        var triggerPrice interface{} = nil
        if v, ok := decoded["triggerPrice"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                triggerPrice = f
            }
            delete(decoded, "triggerPrice")
        }
        
        res := <-e.exchange.CreateStopOrder(symbol, typeVar, side, amount, price, triggerPrice, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) CreateStopLimitOrder(symbol string, side string, amount float64, price float64, triggerPrice float64, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.CreateStopLimitOrder(symbol, side, amount, price, triggerPrice, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) CreateStopMarketOrder(symbol string, side string, amount float64, triggerPrice float64, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.CreateStopMarketOrder(symbol, side, amount, triggerPrice, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchLastPrices(params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbols interface{} = nil
        if v, ok := decoded["symbols"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbols = f
            }
            delete(decoded, "symbols")
        }
        
        res := <-e.exchange.FetchLastPrices(symbols, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchTradingFees(params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.FetchTradingFees(decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchTradingFee(symbol string, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.FetchTradingFee(symbol, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchConvertCurrencies(params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.FetchConvertCurrencies(decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchFundingRate(symbol string, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.FetchFundingRate(symbol, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchFundingInterval(symbol string, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        
        res := <-e.exchange.FetchFundingInterval(symbol, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchMarkOHLCV(symbol string, timeframe []byte, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            }
            delete(decoded, "limit")
        }
        
        res := <-e.exchange.FetchMarkOHLCV(symbol, timeframe, since, limit, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchIndexOHLCV(symbol string, timeframe []byte, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            }
            delete(decoded, "limit")
        }
        
        res := <-e.exchange.FetchIndexOHLCV(symbol, timeframe, since, limit, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchPremiumIndexOHLCV(symbol string, timeframe []byte, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            }
            delete(decoded, "limit")
        }
        
        res := <-e.exchange.FetchPremiumIndexOHLCV(symbol, timeframe, since, limit, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchTransactions(params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var code interface{} = nil
        if v, ok := decoded["code"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                code = f
            }
            delete(decoded, "code")
        }

        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            }
            delete(decoded, "limit")
        }
        
        res := <-e.exchange.FetchTransactions(code, since, limit, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchPositionHistory(symbol string, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            }
            delete(decoded, "limit")
        }
        
        res := <-e.exchange.FetchPositionHistory(symbol, since, limit, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchPositionsHistory(params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var symbols interface{} = nil
        if v, ok := decoded["symbols"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                symbols = f
            }
            delete(decoded, "symbols")
        }

        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            }
            delete(decoded, "limit")
        }
        
        res := <-e.exchange.FetchPositionsHistory(symbols, since, limit, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchTransfer(id string, params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var code interface{} = nil
        if v, ok := decoded["code"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                code = f
            }
            delete(decoded, "code")
        }
        
        res := <-e.exchange.FetchTransfer(id, code, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }

    func (e *CCXTGoExchange) FetchTransfers(params []byte) ([]byte, error) {
        var decoded map[string]interface{}
        if err := json.Unmarshal(params, &decoded); err != nil {
            return nil, err
        }
        
        var code interface{} = nil
        if v, ok := decoded["code"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                code = f
            }
            delete(decoded, "code")
        }

        var since interface{} = nil
        if v, ok := decoded["since"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                since = f
            }
            delete(decoded, "since")
        }

        var limit interface{} = nil
        if v, ok := decoded["limit"]; ok && v != nil {
            if f, ok := v.([]interface{}); ok {
                limit = f
            }
            delete(decoded, "limit")
        }
        
        res := <-e.exchange.FetchTransfers(code, since, limit, decoded)
        if err, ok := res.(error); ok {
            return nil, err
        }
        sanitised := sanitise(res)
        return json.Marshal(sanitised)
    }
