// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

import Foundation
import CCXTCore

extension Exchange.CCXTError: LocalizedError {
    public var errorDescription: String? {
        switch self {
        case .exchange(let msg):
            return msg                          // show the exchange text
        case .decoding(let err):
            return "JSON decoding failed: \(err.localizedDescription)"
        }
    }
}

public class Exchange {
    private let exchange: CcxtCCXTGoExchange
    
    public init?(exchangeName: String, config: [String: Any]? = nil) {
        let configString: String

        if let config = config,
           let jsonData = try? JSONSerialization.data(withJSONObject: config, options: []),
           let jsonString = String(data: jsonData, encoding: .utf8) {
            configString = jsonString
        } else {
            configString = "{}"
        }
        guard let ex = CcxtNewExchange(exchangeName, configString) else {
            return nil
        }
        self.exchange = ex
    }

    private func cleanAny(_ value: Any) -> Any? {
        switch value {
        case is NSNull:
            return nil
        case let number as NSNumber:
            if CFGetTypeID(number) == CFBooleanGetTypeID() {
                return number.boolValue
            } else {
                return number
            }
        case let dict as [String: Any]:
            var cleaned: [String: Any] = [:]
            for (key, val) in dict {
                if let cleanedVal = cleanAny(val) {
                    cleaned[key] = cleanedVal
                }
            }
            return cleaned
        case let array as [Any]:
            return array.compactMap { cleanAny($0) }
        default:
            return value
        }
    }

    private func stringify<T: Encodable>(_ object: T, prettyPrinted: Bool = false) -> String? {
        let encoder = JSONEncoder()
        if prettyPrinted {
            encoder.outputFormatting = .prettyPrinted
        }

        do {
            let data = try encoder.encode(object)
            return String(data: data, encoding: .utf8)
        } catch {
            print("Failed to stringify object: \(error)")
            return nil
        }
    }
    
    public enum CCXTError: Error {
        case exchange(String)   // message coming back from the Go layer / exchange
        case decoding(Error)    // genuine JSON-decoding problem
    }
    
    private func decode(_ data: Data) throws -> Any {
        // First, try to parse as JSON, the normal successful path
        do {
            return try JSONSerialization.jsonObject(with: data, options: [])
        } catch {
            // Not valid JSON -> might be a ccxt panic string. Check that format.
            // Expected format (single-line, simplified):
            //   "panic: ... [ccxtError]::[<ErrorClass>]::[<exchange> {\"code\":...,\"msg\":...}]\nStack:\n"
            if let s = String(data: data, encoding: .utf8) {
                // Try to extract the segment after the last "[ccxtError]::["
                // Split by "::"- panic string delimeter
                let segments = s.components(separatedBy: "::")
                if segments.count >= 3,
                   segments[0].contains("[ccxtError]") {
                    // Example segments:
                    //  [0] ...[ccxtError]
                    //  [1] "[ExchangeError]"
                    //  [2] "[bitget {\"code\":...}..."
                    // Extract error type (remove brackets)
                    let rawType = segments[1].trimmingCharacters(in: CharacterSet(charactersIn: "[]"))

                    // message embedded in a JSON object -> {"msg": ...}
                    if let jsonStart = s.firstIndex(of: "{"),
                       let jsonEnd = s[jsonStart...].firstIndex(of: "}") {

                        let jsonRange = jsonStart...jsonEnd
                        var jsonSubstring = String(s[jsonRange])
                        jsonSubstring = jsonSubstring.replacingOccurrences(of: "\\\"", with: "\"")

                        if let jsonData = jsonSubstring.data(using: .utf8),
                           let jsonObj = try? JSONSerialization.jsonObject(with: jsonData) as? [String: Any] {

                            let message = (jsonObj["msg"] as? String) ??
                                           (jsonObj["message"] as? String) ?? jsonSubstring

                            if let errorClass = NSClassFromString("CCXTSwift.\(rawType)") as? BaseError.Type {
                                throw errorClass.init(message)
                            }
                            throw CCXTError.exchange(message)
                        }
                    }

                    // plain message wrapped in brackets, take last segment
                    let tail = segments.last ?? ""
                    var plainMsg = tail.replacingOccurrences(
                                      of: "]\\nStack:\\n\"",  // literal ]\nStack:\n"
                                      with: "")

                    plainMsg = plainMsg.trimmingCharacters(
                                   in: CharacterSet(charactersIn: "[]\"\n "))

                    if let errorClass = NSClassFromString("CCXTSwift.\(rawType)") as? BaseError.Type {
                        throw errorClass.init(plainMsg)
                    }
                    throw CCXTError.exchange(plainMsg)
                }
                // Could read as UTF-8 but not recognised panic format
                throw CCXTError.exchange(s.trimmingCharacters(in: .whitespacesAndNewlines))
            }
            // Still unknown binary payload
            throw CCXTError.decoding(error)
        }
    }

    // ------------------------------------------------------------------------

    // ########################################################################
    // ########################################################################
    // ########################################################################
    // ########################################################################
    // ########                        ########                        ########
    // ########                        ########                        ########
    // ########                        ########                        ########
    // ########                        ########                        ########
    // ########        ########################        ########################
    // ########        ########################        ########################
    // ########        ########################        ########################
    // ########        ########################        ########################
    // ########                        ########                        ########
    // ########                        ########                        ########
    // ########                        ########                        ########
    // ########                        ########                        ########
    // ########################################################################
    // ########################################################################
    // ########################################################################
    // ########################################################################
    // ########        ########        ########                        ########
    // ########        ########        ########                        ########
    // ########        ########        ########                        ########
    // ########        ########        ########                        ########
    // ################        ########################        ################
    // ################        ########################        ################
    // ################        ########################        ################
    // ################        ########################        ################
    // ########        ########        ################        ################
    // ########        ########        ################        ################
    // ########        ########        ################        ################
    // ########        ########        ################        ################
    // ########################################################################
    // ########################################################################
    // ########################################################################
    // ########################################################################

    // ------------------------------------------------------------------------
    // METHODS BELOW THIS LINE ARE TRANSPILED

    public func loadMarkets (reload: Bool = false, params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.loadMarkets(reload, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchCurrencies (params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchCurrencies(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchMarkets (params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchMarkets(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchAccounts (params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchAccounts(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchTrades (symbol: String, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchTrades(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchDepositAddresses (codes: [String]? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (codes != nil) { paramsCopy["codes"] = codes }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchDepositAddresses(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchOrderBook (symbol: String, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchOrderBook(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchMarginMode (symbol: String, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchMarginMode(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchMarginModes (symbols: [String]? = nil, params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchMarginModes(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchTime (params: [String: Any] = [:]) async throws -> Int? {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchTime(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Int?)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchTradingLimits (symbols: [String]? = nil, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchTradingLimits(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchCrossBorrowRates (params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchCrossBorrowRates(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchIsolatedBorrowRates (params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchIsolatedBorrowRates(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchLeverageTiers (symbols: [String]? = nil, params: [String: Any] = [:]) async throws -> [String: [[String: Any]]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchLeverageTiers(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [[String: Any]]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchFundingRates (symbols: [String]? = nil, params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchFundingRates(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchFundingIntervals (symbols: [String]? = nil, params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchFundingIntervals(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func transfer (code: String, amount: Double, fromAccount: String, toAccount: String, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.transfer(code, amount: amount, fromAccount: fromAccount, toAccount: toAccount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func withdraw (code: String, amount: Double, address: String, tag: String? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (tag != nil) { paramsCopy["tag"] = tag }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.withdraw(code, amount: amount, address: address, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createDepositAddress (code: String, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.createDepositAddress(code, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func setLeverage (leverage: Int, symbol: String? = nil, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.setLeverage(leverage, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchLeverage (symbol: String, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchLeverage(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchLeverages (symbols: [String]? = nil, params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchLeverages(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func setPositionMode (hedged: Bool, symbol: String? = nil, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.setPositionMode(hedged, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func addMargin (symbol: String, amount: Double, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.addMargin(symbol, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func reduceMargin (symbol: String, amount: Double, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.reduceMargin(symbol, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func setMargin (symbol: String, amount: Double, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.setMargin(symbol, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchLongShortRatio (symbol: String, timeframe: String? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (timeframe != nil) { paramsCopy["timeframe"] = timeframe }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchLongShortRatio(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchLongShortRatioHistory (symbol: String? = nil, timeframe: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
					if (timeframe != nil) { paramsCopy["timeframe"] = timeframe }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchLongShortRatioHistory(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchMarginAdjustmentHistory (symbol: String? = nil, type: String? = nil, since: Double? = nil, limit: Double? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
					if (type != nil) { paramsCopy["type"] = type }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchMarginAdjustmentHistory(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func setMarginMode (marginMode: String, symbol: String? = nil, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.setMarginMode(marginMode, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchDepositAddressesByNetwork (code: String, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchDepositAddresses(byNetwork: code, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchOpenInterestHistory (symbol: String, timeframe: String = "1h", since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchOpenInterestHistory(symbol, timeframe: timeframe, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchOpenInterest (symbol: String, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchOpenInterest(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchOpenInterests (symbols: [String]? = nil, params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchOpenInterests(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func signIn (params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.sign(in: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchBorrowRate (code: String, amount: Double, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchBorrowRate(code, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func repayCrossMargin (code: String, amount: Double, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.repayCrossMargin(code, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func repayIsolatedMargin (symbol: String, code: String, amount: Double, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.repayIsolatedMargin(symbol, code: code, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func borrowCrossMargin (code: String, amount: Double, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.borrowCrossMargin(code, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func borrowIsolatedMargin (symbol: String, code: String, amount: Double, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.borrowIsolatedMargin(symbol, code: code, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func borrowMargin (code: String, amount: Double, symbol: String? = nil, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.borrowMargin(code, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchOHLCV (symbol: String, timeframe: Any = "1m", since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[Double]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchOHLCV(symbol, timeframe: timeframe, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[Double]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchL2OrderBook (symbol: String, limit: Int? = nil, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchL2OrderBook(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func editOrder (id: String, symbol: String, type: String, side: String?, amount: Double? = nil, price: Double? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (amount != nil) { paramsCopy["amount"] = amount }
					if (price != nil) { paramsCopy["price"] = price }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.editOrder(id, symbol: symbol, typeVar: type, side: side, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchPosition (symbol: String, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchPosition(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchPositionsForSymbol (symbol: String, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchPositions(forSymbol: symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchPositions (symbols: [String]? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchPositions(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchPositionsRisk (symbols: [String]? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchPositionsRisk(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchBidsAsks (symbols: [String]? = nil, params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchBidsAsks(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchBorrowInterest (code: String? = nil, symbol: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (code != nil) { paramsCopy["code"] = code }
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchBorrowInterest(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchLedger (code: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (code != nil) { paramsCopy["code"] = code }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchLedger(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchLedgerEntry (id: String, code: String? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (code != nil) { paramsCopy["code"] = code }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchLedgerEntry(id, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchBalance (params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchBalance(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchStatus (params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchStatus(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchTransactionFee (code: String, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchTransactionFee(code, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchTransactionFees (codes: [String]? = nil, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (codes != nil) { paramsCopy["codes"] = codes }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchTransactionFees(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchDepositWithdrawFees (codes: [String]? = nil, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (codes != nil) { paramsCopy["codes"] = codes }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchDepositWithdrawFees(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchDepositWithdrawFee (code: String, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchDepositWithdrawFee(code, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchCrossBorrowRate (code: String, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchCrossBorrowRate(code, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchIsolatedBorrowRate (symbol: String, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchIsolatedBorrowRate(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchTicker (symbol: String, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchTicker(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchTickers (symbols: [String]? = nil, params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchTickers(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchMarkPrices (symbols: [String]? = nil, params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchMarkPrices(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchOrderBooks (symbols: [String]? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchOrderBooks(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchOrder (id: String, symbol: String? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchOrder(id, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createOrder (symbol: String, type: String, side: String?, amount: Double, price: Double? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (price != nil) { paramsCopy["price"] = price }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.createOrder(symbol, typeVar: type, side: side, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchConvertTrade (id: String, code: String? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (code != nil) { paramsCopy["code"] = code }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchConvertTrade(id, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchConvertTradeHistory (code: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (code != nil) { paramsCopy["code"] = code }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchConvertTradeHistory(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchPositionMode (symbol: String? = nil, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchPositionMode(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createTrailingAmountOrder (symbol: String, type: String, side: String?, amount: Double, price: Double? = nil, trailingAmount: Double? = nil, trailingTriggerPrice: Double? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (price != nil) { paramsCopy["price"] = price }
					if (trailingAmount != nil) { paramsCopy["trailingAmount"] = trailingAmount }
					if (trailingTriggerPrice != nil) { paramsCopy["trailingTriggerPrice"] = trailingTriggerPrice }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.createTrailingAmountOrder(symbol, typeVar: type, side: side, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createTrailingPercentOrder (symbol: String, type: String, side: String?, amount: Double, price: Double? = nil, trailingPercent: Double? = nil, trailingTriggerPrice: Double? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (price != nil) { paramsCopy["price"] = price }
					if (trailingPercent != nil) { paramsCopy["trailingPercent"] = trailingPercent }
					if (trailingTriggerPrice != nil) { paramsCopy["trailingTriggerPrice"] = trailingTriggerPrice }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.createTrailingPercentOrder(symbol, typeVar: type, side: side, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createMarketOrderWithCost (symbol: String, side: String?, cost: Double, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.createMarketOrder(withCost: symbol, side: side, cost: cost, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createMarketBuyOrderWithCost (symbol: String, cost: Double, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.createMarketBuyOrder(withCost: symbol, cost: cost, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createMarketSellOrderWithCost (symbol: String, cost: Double, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.createMarketSellOrder(withCost: symbol, cost: cost, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createTriggerOrder (symbol: String, type: String, side: String?, amount: Double, price: Double? = nil, triggerPrice: Double? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (price != nil) { paramsCopy["price"] = price }
					if (triggerPrice != nil) { paramsCopy["triggerPrice"] = triggerPrice }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.createTriggerOrder(symbol, typeVar: type, side: side, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createStopLossOrder (symbol: String, type: String, side: String?, amount: Double, price: Double? = nil, stopLossPrice: Double? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (price != nil) { paramsCopy["price"] = price }
					if (stopLossPrice != nil) { paramsCopy["stopLossPrice"] = stopLossPrice }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.createStopLossOrder(symbol, typeVar: type, side: side, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createTakeProfitOrder (symbol: String, type: String, side: String?, amount: Double, price: Double? = nil, takeProfitPrice: Double? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (price != nil) { paramsCopy["price"] = price }
					if (takeProfitPrice != nil) { paramsCopy["takeProfitPrice"] = takeProfitPrice }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.createTakeProfitOrder(symbol, typeVar: type, side: side, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createOrderWithTakeProfitAndStopLoss (symbol: String, type: String, side: String?, amount: Double, price: Double? = nil, takeProfit: Double? = nil, stopLoss: Double? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (price != nil) { paramsCopy["price"] = price }
					if (takeProfit != nil) { paramsCopy["takeProfit"] = takeProfit }
					if (stopLoss != nil) { paramsCopy["stopLoss"] = stopLoss }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.createOrder(withTakeProfitAndStopLoss: symbol, typeVar: type, side: side, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func cancelOrder (id: String, symbol: String? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.cancelOrder(id, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func cancelAllOrders (symbol: String? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.cancelAllOrders(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchOrders (symbol: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchOrders(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchOrderTrades (id: String, symbol: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchOrderTrades(id, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchOpenOrders (symbol: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchOpenOrders(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchClosedOrders (symbol: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchClosedOrders(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchCanceledAndClosedOrders (symbol: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchCanceledAndClosedOrders(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchMyTrades (symbol: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchMyTrades(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchMyLiquidations (symbol: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchMyLiquidations(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchLiquidations (symbol: String, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchLiquidations(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchGreeks (symbol: String, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchGreeks(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchOptionChain (code: String, params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchOptionChain(code, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchOption (symbol: String, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchOption(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchConvertQuote (fromCode: String, toCode: String, amount: Double? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (amount != nil) { paramsCopy["amount"] = amount }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchConvertQuote(fromCode, toCode: toCode, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchDepositsWithdrawals (code: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (code != nil) { paramsCopy["code"] = code }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchDepositsWithdrawals(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchDeposits (code: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (code != nil) { paramsCopy["code"] = code }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchDeposits(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchWithdrawals (code: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (code != nil) { paramsCopy["code"] = code }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchWithdrawals(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchFundingRateHistory (symbol: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchFundingRateHistory(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchFundingHistory (symbol: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchFundingHistory(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func closePosition (symbol: String, side: String? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (side != nil) { paramsCopy["side"] = side }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.closePosition(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func closeAllPositions (params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.closeAllPositions(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchL3OrderBook (symbol: String, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchL3OrderBook(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchDepositAddress (code: String, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchDepositAddress(code, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createLimitOrder (symbol: String, side: String?, amount: Double, price: Double, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.createLimitOrder(symbol, side: side, amount: amount, price: price, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createMarketOrder (symbol: String, side: String?, amount: Double, price: Double? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (price != nil) { paramsCopy["price"] = price }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.createMarketOrder(symbol, side: side, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createLimitBuyOrder (symbol: String, amount: Double, price: Double, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.createLimitBuyOrder(symbol, amount: amount, price: price, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createLimitSellOrder (symbol: String, amount: Double, price: Double, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.createLimitSellOrder(symbol, amount: amount, price: price, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createMarketBuyOrder (symbol: String, amount: Double, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.createMarketBuyOrder(symbol, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createMarketSellOrder (symbol: String, amount: Double, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.createMarketSellOrder(symbol, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchMarketLeverageTiers (symbol: String, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchMarketLeverageTiers(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createPostOnlyOrder (symbol: String, type: String, side: String?, amount: Double, price: Double? = nil, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (price != nil) { paramsCopy["price"] = price }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.createPostOnlyOrder(symbol, typeVar: type, side: side, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createReduceOnlyOrder (symbol: String, type: String, side: String?, amount: Double, price: Double? = nil, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (price != nil) { paramsCopy["price"] = price }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.createReduceOnlyOrder(symbol, typeVar: type, side: side, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createStopOrder (symbol: String, type: String, side: String?, amount: Double, price: Double? = nil, triggerPrice: Double? = nil, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (price != nil) { paramsCopy["price"] = price }
					if (triggerPrice != nil) { paramsCopy["triggerPrice"] = triggerPrice }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.createStopOrder(symbol, typeVar: type, side: side, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createStopLimitOrder (symbol: String, side: String?, amount: Double, price: Double, triggerPrice: Double, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.createStopLimitOrder(symbol, side: side, amount: amount, price: price, triggerPrice: triggerPrice, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createStopMarketOrder (symbol: String, side: String?, amount: Double, triggerPrice: Double, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.createStopMarketOrder(symbol, side: side, amount: amount, triggerPrice: triggerPrice, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchLastPrices (symbols: [String]? = nil, params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchLastPrices(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchTradingFees (params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchTradingFees(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchTradingFee (symbol: String, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchTradingFee(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchConvertCurrencies (params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchConvertCurrencies(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchFundingRate (symbol: String, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchFundingRate(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchFundingInterval (symbol: String, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchFundingInterval(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchMarkOHLCV (symbol: String, timeframe: Any = "1m", since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[Double]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchMarkOHLCV(symbol, timeframe: timeframe, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[Double]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchIndexOHLCV (symbol: String, timeframe: Any = "1m", since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[Double]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchIndexOHLCV(symbol, timeframe: timeframe, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[Double]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchPremiumIndexOHLCV (symbol: String, timeframe: Any = "1m", since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[Double]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchPremiumIndexOHLCV(symbol, timeframe: timeframe, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[Double]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchTransactions (code: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (code != nil) { paramsCopy["code"] = code }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchTransactions(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchPositionHistory (symbol: String, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchPositionHistory(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchPositionsHistory (symbols: [String]? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchPositionsHistory(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchTransfer (id: String, code: String? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (code != nil) { paramsCopy["code"] = code }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchTransfer(id, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchTransfers (code: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (code != nil) { paramsCopy["code"] = code }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchTransfers(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


}
