// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

import Foundation
import CCXTCore

extension Exchange.CCXTError: LocalizedError {
    public var errorDescription: String? {
        switch self {
        case .exchange(let msg):
            return msg                          // show the exchange text
        case .decoding(let err):
            return "JSON decoding failed: \(err.localizedDescription)"
        }
    }
}

public class Exchange {
    private let exchange: CcxtCCXTGoExchange
    
    public init?(exchangeName: String, config: [String: Any]? = nil) {
        let configString: String

        if let config = config,
           let jsonData = try? JSONSerialization.data(withJSONObject: config, options: []),
           let jsonString = String(data: jsonData, encoding: .utf8) {
            configString = jsonString
        } else {
            configString = "{}"
        }
        guard let ex = CcxtNewExchange(exchangeName, configString) else {
            return nil
        }
        self.exchange = ex
    }

    private func cleanAny(_ value: Any) -> Any? {
        switch value {
        case is NSNull:
            return nil
        case let number as NSNumber:
            if CFGetTypeID(number) == CFBooleanGetTypeID() {
                return number.boolValue
            } else {
                return number
            }
        case let dict as [String: Any]:
            var cleaned: [String: Any] = [:]
            for (key, val) in dict {
                if let cleanedVal = cleanAny(val) {
                    cleaned[key] = cleanedVal
                }
            }
            return cleaned
        case let array as [Any]:
            return array.compactMap { cleanAny($0) }
        default:
            return value
        }
    }

    private func stringify<T: Encodable>(_ object: T, prettyPrinted: Bool = false) -> String? {
        let encoder = JSONEncoder()
        if prettyPrinted {
            encoder.outputFormatting = .prettyPrinted
        }

        do {
            let data = try encoder.encode(object)
            return String(data: data, encoding: .utf8)
        } catch {
            print("Failed to stringify object: \(error)")
            return nil
        }
    }
    
    public enum CCXTError: Error {
        case exchange(String)   // message coming back from the Go layer / exchange
        case decoding(Error)    // genuine JSON-decoding problem
    }
    
    private func decode(_ value: Any?) throws -> Any? {
    guard let value = value else {
        return nil
    }

    switch value {
    case let data as Data:
        // Quick check for literal boolean
        if let s = String(data: data, encoding: .utf8)?.trimmingCharacters(in: .whitespacesAndNewlines) {
            if s == "true" { return true }
            if s == "false" { return false }
            if s == "null" { return nil }
            // NEW: also parse number-like strings here
            if let intVal = Int(s) { return intVal }
            if let doubleVal = Double(s) { return doubleVal }
        }

        do {
            // Normal JSON parse
            return try JSONSerialization.jsonObject(with: data, options: [])
        } catch {
            // Only attempt CCXT panic parsing if data can be UTF-8 string and matches the panic format
            if let s = String(data: data, encoding: .utf8),
               s.contains("[ccxtError]::[") {

                let segments = s.components(separatedBy: "::")
                if segments.count >= 3 {
                    let rawType = segments[1].trimmingCharacters(in: CharacterSet(charactersIn: "[]"))

                    // Try to extract JSON message if available
                    if let jsonStart = s.firstIndex(of: "{"),
                       let jsonEnd = s[jsonStart...].firstIndex(of: "}") {
                        var jsonSubstring = String(s[jsonStart...jsonEnd])
                        jsonSubstring = jsonSubstring.replacingOccurrences(of: "\\\"", with: "\"")

                        if let jsonData = jsonSubstring.data(using: .utf8),
                           let jsonObj = try? JSONSerialization.jsonObject(with: jsonData) as? [String: Any] {
                            let message = (jsonObj["msg"] as? String) ??
                                          (jsonObj["message"] as? String) ??
                                          jsonSubstring

                            if let errorClass = NSClassFromString("CCXTSwift.\(rawType)") as? BaseError.Type {
                                throw errorClass.init(message)
                            }
                            throw CCXTError.exchange(message)
                        }
                    }

                    // Plain message fallback
                    let tail = segments.last ?? ""
                    var plainMsg = tail.replacingOccurrences(of: "]\\nStack:\\n\"", with: "")
                    plainMsg = plainMsg.trimmingCharacters(in: CharacterSet(charactersIn: "[]\"\n "))

                    if let errorClass = NSClassFromString("CCXTSwift.\(rawType)") as? BaseError.Type {
                        throw errorClass.init(plainMsg)
                    }
                    throw CCXTError.exchange(plainMsg)
                }
            }

            // Non-panic string / invalid JSON â†’ return string as-is
            if let s = String(data: data, encoding: .utf8) {
                // NEW: parse number-like strings here too
                if let intVal = Int(s) { return intVal }
                if let doubleVal = Double(s) { return doubleVal }
                return s
            }

            throw CCXTError.decoding(error)
        }

    case let str as String:
        // Try to parse string into number if possible
        if let intVal = Int(str) {
            return intVal
        }
        if let doubleVal = Double(str) {
            return doubleVal
        }
        return str

    case let number as NSNumber:
        if CFGetTypeID(number) == CFBooleanGetTypeID() {
            return number.boolValue
        } else if CFNumberIsFloatType(number) {
            return number.doubleValue
        } else {
            return number.intValue
        }

    case let bool as Bool:
        return bool

    default:
        return value
    }
    }



    // ------------------------------------------------------------------------

    // ########################################################################
    // ########################################################################
    // ########################################################################
    // ########################################################################
    // ########                        ########                        ########
    // ########                        ########                        ########
    // ########                        ########                        ########
    // ########                        ########                        ########
    // ########        ########################        ########################
    // ########        ########################        ########################
    // ########        ########################        ########################
    // ########        ########################        ########################
    // ########                        ########                        ########
    // ########                        ########                        ########
    // ########                        ########                        ########
    // ########                        ########                        ########
    // ########################################################################
    // ########################################################################
    // ########################################################################
    // ########################################################################
    // ########        ########        ########                        ########
    // ########        ########        ########                        ########
    // ########        ########        ########                        ########
    // ########        ########        ########                        ########
    // ################        ########################        ################
    // ################        ########################        ################
    // ################        ########################        ################
    // ################        ########################        ################
    // ########        ########        ################        ################
    // ########        ########        ################        ################
    // ########        ########        ################        ################
    // ########        ########        ################        ################
    // ########################################################################
    // ########################################################################
    // ########################################################################
    // ########################################################################

    // ------------------------------------------------------------------------
    // METHODS BELOW THIS LINE ARE TRANSPILED

    public var isSandboxModeEnabled: Bool {
        get {
            guard let propValue = try? self.exchange.getIsSandboxModeEnabled() else {
                return false
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Bool
            return cleaned
        }
        set {
            try? self.exchange.setIsSandboxModeEnabled(newValue as! Bool)
        }
    }

    public var api: [String: Any] {
        get {
            guard let propValue = try? self.exchange.getApi() else {
                return [:]
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: Any]
            return cleaned
        }
        
    }

    public var userAgent: String? {
        get {
            guard let propValue = try? self.exchange.getUserAgent() else {
                return nil
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! String?
            return cleaned
        }
        set {
            try? self.exchange.setUserAgent(newValue as! String)
        }
    }

    public var userAgents: [String: String] {
        get {
            guard let propValue = try? self.exchange.getUserAgents() else {
                return [:]
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: String]
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setUserAgents(serialized)
        }
    }

    public var returnResponseHeaders: Bool {
        get {
            guard let propValue = try? self.exchange.getReturnResponseHeaders() else {
                return false
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Bool
            return cleaned
        }
        set {
            try? self.exchange.setReturnResponseHeaders(newValue as! Bool)
        }
    }

    public var MAX_VALUE: Double {
        get {
            guard let propValue = try? self.exchange.getMAX_VALUE() else {
                return 0
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Double
            return cleaned
        }
        set {
            try? self.exchange.setMAX_VALUE(newValue as! Double)
        }
    }

    public var substituteCommonCurrencyCodes: Bool {
        get {
            guard let propValue = try? self.exchange.getSubstituteCommonCurrencyCodes() else {
                return false
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Bool
            return cleaned
        }
        set {
            try? self.exchange.setSubstituteCommonCurrencyCodes(newValue as! Bool)
        }
    }

    public var reduceFees: Bool {
        get {
            guard let propValue = try? self.exchange.getReduceFees() else {
                return false
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Bool
            return cleaned
        }
        set {
            try? self.exchange.setReduceFees(newValue as! Bool)
        }
    }

    public func setTimeout(newValue: Int64) {
        try? self.exchange.setTimeout(newValue as! Int64)
    }

    public func setVerbose(newValue: Bool) {
        try? self.exchange.setVerbose(newValue as! Bool)
    }

    public func setTwofa(newValue: String) {
        try? self.exchange.setTwofa(newValue as! String)
    }

    public var balance: Any {
        get {
            guard let propValue = try? self.exchange.getBalance() else {
                return [:]
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Any
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setBalance(serialized)
        }
    }

    public var liquidations: [String: [String: Any]] {
        get {
            guard let propValue = try? self.exchange.getLiquidations() else {
                return [:]
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: [String: Any]]
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setLiquidations(serialized)
        }
    }

    public var orderbooks: [String: [String: Any]] {
        get {
            guard let propValue = try? self.exchange.getOrderbooks() else {
                return [:]
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: [String: Any]]
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setOrderbooks(serialized)
        }
    }

    public var tickers: [String: [String: Any]] {
        get {
            guard let propValue = try? self.exchange.getTickers() else {
                return [:]
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: [String: Any]]
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setTickers(serialized)
        }
    }

    public var fundingRates: [String: [String: Any]] {
        get {
            guard let propValue = try? self.exchange.getFundingRates() else {
                return [:]
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: [String: Any]]
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setFundingRates(serialized)
        }
    }

    public var bidsasks: [String: [String: Any]] {
        get {
            guard let propValue = try? self.exchange.getBidsasks() else {
                return [:]
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: [String: Any]]
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setBidsasks(serialized)
        }
    }

    public var orders: Any {
        get {
            guard let propValue = try? self.exchange.getOrders() else {
                return [:]
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Any
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setOrders(serialized)
        }
    }

    public var triggerOrders: Any {
        get {
            guard let propValue = try? self.exchange.getTriggerOrders() else {
                return [:]
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Any
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setTriggerOrders(serialized)
        }
    }

    public var transactions: [String: [String: Any]] {
        get {
            guard let propValue = try? self.exchange.getTransactions() else {
                return [:]
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: [String: Any]]
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setTransactions(serialized)
        }
    }

    public var myLiquidations: [String: [String: Any]] {
        get {
            guard let propValue = try? self.exchange.getMyLiquidations() else {
                return [:]
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: [String: Any]]
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setMyLiquidations(serialized)
        }
    }

    public var precision: [String: Any]? {
        get {
            guard let propValue = try? self.exchange.getPrecision() else {
                return [:]
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: Any]?
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setPrecision(serialized)
        }
    }

    public var last_http_response: Any {
        get {
            guard let propValue = try? self.exchange.getLast_http_response() else {
                return [:]
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Any
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setLast_http_response(serialized)
        }
    }

    public var last_request_headers: [String: String] {
        get {
            guard let propValue = try? self.exchange.getLast_request_headers() else {
                return [:]
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: String]
            return cleaned
        }
        
    }

    public var last_request_body: Any {
        get {
            guard let propValue = try? self.exchange.getLast_request_body() else {
                return [:]
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Any
            return cleaned
        }
        
    }

    public var last_request_url: String {
        get {
            guard let propValue = try? self.exchange.getLast_request_url() else {
                return ""
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! String
            return cleaned
        }
        
    }

    public var id: String {
        get {
            guard let propValue = try? self.exchange.getId() else {
                return ""
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! String
            return cleaned
        }
        
    }

    public var markets: [String: Any] {
        get {
            guard let propValue = try? self.exchange.getMarkets() else {
                return [:]
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: Any]
            return cleaned
        }
        
    }

    public var features: [String: [String: Any]] {
        get {
            guard let propValue = try? self.exchange.getFeatures() else {
                return [:]
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: [String: Any]]
            return cleaned
        }
        
    }

    public var rateLimit: Double {
        get {
            guard let propValue = try? self.exchange.getRateLimit() else {
                return 0
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Double
            return cleaned
        }
        set {
            try? self.exchange.setRateLimit(newValue as! Double)
        }
    }

    public var tokenBucket: [String: Double] {
        get {
            guard let propValue = try? self.exchange.getTokenBucket() else {
                return [:]
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: Double]
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setTokenBucket(serialized)
        }
    }

    public var throttler: Any {
        get {
            guard let propValue = try? self.exchange.getThrottler() else {
                return [:]
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Any
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setThrottler(serialized)
        }
    }

    public func setEnableRateLimit(newValue: Bool) {
        try? self.exchange.setEnableRateLimit(newValue as! Bool)
    }

    public var httpExceptions: [String: Any] {
        get {
            guard let propValue = try? self.exchange.getHttpExceptions() else {
                return [:]
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: Any]
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setHttpExceptions(serialized)
        }
    }

    public var limits: [String: Any]? {
        get {
            guard let propValue = try? self.exchange.getLimits() else {
                return [:]
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: Any]?
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setLimits(serialized)
        }
    }

    public var markets_by_id: [String: Any] {
        get {
            guard let propValue = try? self.exchange.getMarkets_by_id() else {
                return [:]
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: Any]
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setMarkets_by_id(serialized)
        }
    }

    public var symbols: Strings {
        get {
            guard let propValue = try? self.exchange.getSymbols() else {
                return nil
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Strings
            return cleaned
        }
        
    }

    public var ids: Strings {
        get {
            guard let propValue = try? self.exchange.getIds() else {
                return nil
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Strings
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setIds(serialized)
        }
    }

    public var currencies: [String: Any] {
        get {
            guard let propValue = try? self.exchange.getCurrencies() else {
                return [:]
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: Any]
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setCurrencies(serialized)
        }
    }

    public var baseCurrencies: [String: [String: Any]] {
        get {
            guard let propValue = try? self.exchange.getBaseCurrencies() else {
                return [:]
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: [String: Any]]
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setBaseCurrencies(serialized)
        }
    }

    public var quoteCurrencies: [String: [String: Any]] {
        get {
            guard let propValue = try? self.exchange.getQuoteCurrencies() else {
                return [:]
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: [String: Any]]
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setQuoteCurrencies(serialized)
        }
    }

    public var currencies_by_id: [String: [String: Any]] {
        get {
            guard let propValue = try? self.exchange.getCurrencies_by_id() else {
                return [:]
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: [String: Any]]
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setCurrencies_by_id(serialized)
        }
    }

    public var codes: Strings {
        get {
            guard let propValue = try? self.exchange.getCodes() else {
                return nil
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Strings
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setCodes(serialized)
        }
    }

    public func setAccounts(newValue: [[String: Any]]) {
        let serialized = try? JSONSerialization.data(withJSONObject: newValue)
        try? self.exchange.setAccounts(serialized)
    }

    public var accountsById: [String: [String: Any]] {
        get {
            guard let propValue = try? self.exchange.getAccountsById() else {
                return [:]
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: [String: Any]]
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setAccountsById(serialized)
        }
    }

    public var commonCurrencies: [String: String] {
        get {
            guard let propValue = try? self.exchange.getCommonCurrencies() else {
                return [:]
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: String]
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setCommonCurrencies(serialized)
        }
    }

    public var hostname: String? {
        get {
            guard let propValue = try? self.exchange.getHostname() else {
                return nil
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! String?
            return cleaned
        }
        
    }

    public var exceptions: [String: String] {
        get {
            guard let propValue = try? self.exchange.getExceptions() else {
                return [:]
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: String]
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setExceptions(serialized)
        }
    }

    public var timeframes: Any {
        get {
            guard let propValue = try? self.exchange.getTimeframes() else {
                return [:]
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Any
            return cleaned
        }
        
    }

    public var version: String? {
        get {
            guard let propValue = try? self.exchange.getVersion() else {
                return nil
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! String?
            return cleaned
        }
        
    }

    public var name: String? {
        get {
            guard let propValue = try? self.exchange.getName() else {
                return nil
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! String?
            return cleaned
        }
        set {
            try? self.exchange.setName(newValue as! String)
        }
    }

    public var httpProxyAgentModule: Any {
        get {
            guard let propValue = try? self.exchange.getHttpProxyAgentModule() else {
                return [:]
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Any
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setHttpProxyAgentModule(serialized)
        }
    }

    public var httpsProxyAgentModule: Any {
        get {
            guard let propValue = try? self.exchange.getHttpsProxyAgentModule() else {
                return [:]
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Any
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setHttpsProxyAgentModule(serialized)
        }
    }

    public var socksProxyAgentModule: Any {
        get {
            guard let propValue = try? self.exchange.getSocksProxyAgentModule() else {
                return [:]
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Any
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setSocksProxyAgentModule(serialized)
        }
    }

    public var socksProxyAgentModuleChecked: Bool {
        get {
            guard let propValue = try? self.exchange.getSocksProxyAgentModuleChecked() else {
                return false
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Bool
            return cleaned
        }
        set {
            try? self.exchange.setSocksProxyAgentModuleChecked(newValue as! Bool)
        }
    }

    public var proxyDictionaries: [String: Any] {
        get {
            guard let propValue = try? self.exchange.getProxyDictionaries() else {
                return [:]
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: Any]
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setProxyDictionaries(serialized)
        }
    }

    public var alias: Bool {
        get {
            guard let propValue = try? self.exchange.getAlias() else {
                return false
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Bool
            return cleaned
        }
        
    }

    public var clients: [String: Any] {
        get {
            guard let propValue = try? self.exchange.getClients() else {
                return [:]
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: Any]
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setClients(serialized)
        }
    }

    public var newUpdates: Bool {
        get {
            guard let propValue = try? self.exchange.getNewUpdates() else {
                return false
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Bool
            return cleaned
        }
        set {
            try? self.exchange.setNewUpdates(newValue as! Bool)
        }
    }

    public var options: [String: Any] {
        get {
            guard let propValue = try? self.exchange.getOptions() else {
                return [:]
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: Any]
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setOptions(serialized)
        }
    }

    public func setApiKey(newValue: String) {
        try? self.exchange.setApiKey(newValue as! String)
    }

    public func setSecret(newValue: String) {
        try? self.exchange.setSecret(newValue as! String)
    }

    public func setUid(newValue: String) {
        try? self.exchange.setUid(newValue as! String)
    }

    public var login: String {
        get {
            guard let propValue = try? self.exchange.getLogin() else {
                return ""
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! String
            return cleaned
        }
        set {
            try? self.exchange.setLogin(newValue as! String)
        }
    }

    public func setPassword(newValue: String) {
        try? self.exchange.setPassword(newValue as! String)
    }

    public func setPrivateKey(newValue: String) {
        try? self.exchange.setPrivateKey(newValue as! String)
    }

    public func setWalletAddress(newValue: String) {
        try? self.exchange.setWalletAddress(newValue as! String)
    }

    public var token: String {
        get {
            guard let propValue = try? self.exchange.getToken() else {
                return ""
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! String
            return cleaned
        }
        set {
            try? self.exchange.setToken(newValue as! String)
        }
    }

    public var trades: [String: Any] {
        get {
            guard let propValue = try? self.exchange.getTrades() else {
                return [:]
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: Any]
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setTrades(serialized)
        }
    }

    public var ohlcvs: [String: [String: Any]] {
        get {
            guard let propValue = try? self.exchange.getOhlcvs() else {
                return [:]
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: [String: Any]]
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setOhlcvs(serialized)
        }
    }

    public var myTrades: Any {
        get {
            guard let propValue = try? self.exchange.getMyTrades() else {
                return [:]
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Any
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setMyTrades(serialized)
        }
    }

    public var positions: Any {
        get {
            guard let propValue = try? self.exchange.getPositions() else {
                return [:]
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Any
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setPositions(serialized)
        }
    }

    public var has: Any {
        get {
            guard let propValue = try? self.exchange.getHas() else {
                return [:]
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Any
            return cleaned
        }
        
    }

    public var urls: [String: Any] {
        get {
            guard let propValue = try? self.exchange.getUrls() else {
                return [:]
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: Any]
            return cleaned
        }
        
    }

    public var requiredCredentials: [String: Any] {
        get {
            guard let propValue = try? self.exchange.getRequiredCredentials() else {
                return [:]
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: Any]
            return cleaned
        }
        
    }

    public var fees: [String: Any] {
        get {
            guard let propValue = try? self.exchange.getFees() else {
                return [:]
            }
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: Any]
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setFees(serialized)
        }
    }

    public func loadMarkets (reload: Bool = false, params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: [String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.loadMarkets(reload, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchCurrencies (params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: [String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchCurrencies(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchMarkets (params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchMarkets(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func setSandboxMode (enabled: Bool) throws -> Void {
        
                    
                    try self.exchange.setSandboxMode(enabled)
                
    }


    public func fetchAccounts (params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchAccounts(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchTrades (symbol: String, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchTrades(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchDepositAddresses (codes: Strings = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (codes != nil) { paramsCopy["codes"] = codes }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchDepositAddresses(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchOrderBook (symbol: String, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchOrderBook(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchMarginMode (symbol: String, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchMarginMode(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchMarginModes (symbols: Strings = nil, params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: [String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchMarginModes(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchTime (params: [String: Any] = [:]) async throws -> Int? {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Int?, Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchTime(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Int?)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchTradingLimits (symbols: Strings = nil, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Any, Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchTradingLimits(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchCrossBorrowRates (params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: [String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchCrossBorrowRates(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchIsolatedBorrowRates (params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: [String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchIsolatedBorrowRates(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchLeverageTiers (symbols: Strings = nil, params: [String: Any] = [:]) async throws -> [String: [[String: Any]]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: [[String: Any]]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchLeverageTiers(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [[String: Any]]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchFundingRates (symbols: Strings = nil, params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: [String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchFundingRates(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchFundingIntervals (symbols: Strings = nil, params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: [String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchFundingIntervals(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func transfer (code: String, amount: Double, fromAccount: String, toAccount: String, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.transfer(code, amount: amount, fromAccount: fromAccount, toAccount: toAccount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func withdraw (code: String, amount: Double, address: String, tag: String? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (tag != nil) { paramsCopy["tag"] = tag }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.withdraw(code, amount: amount, address: address, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createDepositAddress (code: String, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.createDepositAddress(code, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func setLeverage (leverage: Int, symbol: String? = nil, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Any, Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.setLeverage(leverage, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchLeverage (symbol: String, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchLeverage(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchLeverages (symbols: Strings = nil, params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: [String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchLeverages(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func setPositionMode (hedged: Bool, symbol: String? = nil, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Any, Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.setPositionMode(hedged, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func addMargin (symbol: String, amount: Double, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.addMargin(symbol, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func reduceMargin (symbol: String, amount: Double, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.reduceMargin(symbol, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func setMargin (symbol: String, amount: Double, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.setMargin(symbol, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchLongShortRatio (symbol: String, timeframe: String? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (timeframe != nil) { paramsCopy["timeframe"] = timeframe }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchLongShortRatio(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchLongShortRatioHistory (symbol: String? = nil, timeframe: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
					if (timeframe != nil) { paramsCopy["timeframe"] = timeframe }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchLongShortRatioHistory(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchMarginAdjustmentHistory (symbol: String? = nil, type: String? = nil, since: Double? = nil, limit: Double? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
					if (type != nil) { paramsCopy["type"] = type }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchMarginAdjustmentHistory(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func setMarginMode (marginMode: String, symbol: String? = nil, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Any, Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.setMarginMode(marginMode, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchDepositAddressesByNetwork (code: String, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchDepositAddresses(byNetwork: code, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchOpenInterestHistory (symbol: String, timeframe: String = "1h", since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchOpenInterestHistory(symbol, timeframe: timeframe, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchOpenInterest (symbol: String, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchOpenInterest(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchOpenInterests (symbols: Strings = nil, params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: [String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchOpenInterests(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func signIn (params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Any, Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.sign(in: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchBorrowRate (code: String, amount: Double, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Any, Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchBorrowRate(code, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func repayCrossMargin (code: String, amount: Double, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Any, Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.repayCrossMargin(code, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func repayIsolatedMargin (symbol: String, code: String, amount: Double, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Any, Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.repayIsolatedMargin(symbol, code: code, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func borrowCrossMargin (code: String, amount: Double, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Any, Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.borrowCrossMargin(code, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func borrowIsolatedMargin (symbol: String, code: String, amount: Double, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Any, Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.borrowIsolatedMargin(symbol, code: code, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func borrowMargin (code: String, amount: Double, symbol: String? = nil, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Any, Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.borrowMargin(code, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchOHLCV (symbol: String, timeframe: String = "1m", since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[Double]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[Double]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchOHLCV(symbol, timeframe: timeframe, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[Double]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchL2OrderBook (symbol: String, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchL2OrderBook(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func editOrder (id: String, symbol: String, type: OrderType, side: OrderSide, amount: Double? = nil, price: Double? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (amount != nil) { paramsCopy["amount"] = amount }
					if (price != nil) { paramsCopy["price"] = price }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.editOrder(id, symbol: symbol, typeVar: type, side: side, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchPosition (symbol: String, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchPosition(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchPositionsForSymbol (symbol: String, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchPositions(forSymbol: symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchPositions (symbols: Strings = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchPositions(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchPositionsRisk (symbols: Strings = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchPositionsRisk(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchBidsAsks (symbols: Strings = nil, params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: [String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchBidsAsks(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchBorrowInterest (code: String? = nil, symbol: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (code != nil) { paramsCopy["code"] = code }
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchBorrowInterest(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchLedger (code: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (code != nil) { paramsCopy["code"] = code }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchLedger(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchLedgerEntry (id: String, code: String? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (code != nil) { paramsCopy["code"] = code }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchLedgerEntry(id, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchBalance (params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchBalance(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchStatus (params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Any, Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchStatus(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchTransactionFee (code: String, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Any, Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchTransactionFee(code, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchTransactionFees (codes: Strings = nil, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Any, Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (codes != nil) { paramsCopy["codes"] = codes }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchTransactionFees(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchDepositWithdrawFee (code: String, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Any, Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchDepositWithdrawFee(code, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchCrossBorrowRate (code: String, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchCrossBorrowRate(code, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchIsolatedBorrowRate (symbol: String, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchIsolatedBorrowRate(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchTicker (symbol: String, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchTicker(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchTickers (symbols: Strings = nil, params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: [String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchTickers(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchMarkPrices (symbols: Strings = nil, params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: [String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchMarkPrices(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchOrderBooks (symbols: Strings = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: [String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchOrderBooks(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchOrder (id: String, symbol: String? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchOrder(id, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createOrder (symbol: String, type: OrderType, side: OrderSide, amount: Double, price: Double? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (price != nil) { paramsCopy["price"] = price }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.createOrder(symbol, typeVar: type, side: side, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchConvertTrade (id: String, code: String? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (code != nil) { paramsCopy["code"] = code }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchConvertTrade(id, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchConvertTradeHistory (code: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (code != nil) { paramsCopy["code"] = code }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchConvertTradeHistory(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchPositionMode (symbol: String? = nil, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Any, Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchPositionMode(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createTrailingAmountOrder (symbol: String, type: OrderType, side: OrderSide, amount: Double, price: Double? = nil, trailingAmount: Double? = nil, trailingTriggerPrice: Double? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (price != nil) { paramsCopy["price"] = price }
					if (trailingAmount != nil) { paramsCopy["trailingAmount"] = trailingAmount }
					if (trailingTriggerPrice != nil) { paramsCopy["trailingTriggerPrice"] = trailingTriggerPrice }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.createTrailingAmountOrder(symbol, typeVar: type, side: side, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createTrailingPercentOrder (symbol: String, type: OrderType, side: OrderSide, amount: Double, price: Double? = nil, trailingPercent: Double? = nil, trailingTriggerPrice: Double? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (price != nil) { paramsCopy["price"] = price }
					if (trailingPercent != nil) { paramsCopy["trailingPercent"] = trailingPercent }
					if (trailingTriggerPrice != nil) { paramsCopy["trailingTriggerPrice"] = trailingTriggerPrice }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.createTrailingPercentOrder(symbol, typeVar: type, side: side, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createMarketOrderWithCost (symbol: String, side: OrderSide, cost: Double, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.createMarketOrder(withCost: symbol, side: side, cost: cost, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createMarketBuyOrderWithCost (symbol: String, cost: Double, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.createMarketBuyOrder(withCost: symbol, cost: cost, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createMarketSellOrderWithCost (symbol: String, cost: Double, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.createMarketSellOrder(withCost: symbol, cost: cost, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createTriggerOrder (symbol: String, type: OrderType, side: OrderSide, amount: Double, price: Double? = nil, triggerPrice: Double? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (price != nil) { paramsCopy["price"] = price }
					if (triggerPrice != nil) { paramsCopy["triggerPrice"] = triggerPrice }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.createTriggerOrder(symbol, typeVar: type, side: side, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createStopLossOrder (symbol: String, type: OrderType, side: OrderSide, amount: Double, price: Double? = nil, stopLossPrice: Double? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (price != nil) { paramsCopy["price"] = price }
					if (stopLossPrice != nil) { paramsCopy["stopLossPrice"] = stopLossPrice }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.createStopLossOrder(symbol, typeVar: type, side: side, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createTakeProfitOrder (symbol: String, type: OrderType, side: OrderSide, amount: Double, price: Double? = nil, takeProfitPrice: Double? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (price != nil) { paramsCopy["price"] = price }
					if (takeProfitPrice != nil) { paramsCopy["takeProfitPrice"] = takeProfitPrice }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.createTakeProfitOrder(symbol, typeVar: type, side: side, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createOrderWithTakeProfitAndStopLoss (symbol: String, type: OrderType, side: OrderSide, amount: Double, price: Double? = nil, takeProfit: Double? = nil, stopLoss: Double? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (price != nil) { paramsCopy["price"] = price }
					if (takeProfit != nil) { paramsCopy["takeProfit"] = takeProfit }
					if (stopLoss != nil) { paramsCopy["stopLoss"] = stopLoss }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.createOrder(withTakeProfitAndStopLoss: symbol, typeVar: type, side: side, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func cancelOrder (id: String, symbol: String? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.cancelOrder(id, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func cancelAllOrders (symbol: String? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.cancelAllOrders(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchOrders (symbol: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchOrders(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchOrderTrades (id: String, symbol: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchOrderTrades(id, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchOpenOrders (symbol: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchOpenOrders(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchClosedOrders (symbol: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchClosedOrders(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchCanceledAndClosedOrders (symbol: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchCanceledAndClosedOrders(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchMyTrades (symbol: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchMyTrades(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchMyLiquidations (symbol: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchMyLiquidations(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchLiquidations (symbol: String, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchLiquidations(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchGreeks (symbol: String, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchGreeks(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchOptionChain (code: String, params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: [String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchOptionChain(code, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchOption (symbol: String, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchOption(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchConvertQuote (fromCode: String, toCode: String, amount: Double? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (amount != nil) { paramsCopy["amount"] = amount }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchConvertQuote(fromCode, toCode: toCode, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchDepositsWithdrawals (code: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (code != nil) { paramsCopy["code"] = code }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchDepositsWithdrawals(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchDeposits (code: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (code != nil) { paramsCopy["code"] = code }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchDeposits(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchWithdrawals (code: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (code != nil) { paramsCopy["code"] = code }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchWithdrawals(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchFundingRateHistory (symbol: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchFundingRateHistory(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchFundingHistory (symbol: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchFundingHistory(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func closePosition (symbol: String, side: OrderSide = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (side != nil) { paramsCopy["side"] = side }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.closePosition(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func closeAllPositions (params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.closeAllPositions(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchL3OrderBook (symbol: String, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchL3OrderBook(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchDepositAddress (code: String, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchDepositAddress(code, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createLimitOrder (symbol: String, side: OrderSide, amount: Double, price: Double, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.createLimitOrder(symbol, side: side, amount: amount, price: price, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createMarketOrder (symbol: String, side: OrderSide, amount: Double, price: Double? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (price != nil) { paramsCopy["price"] = price }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.createMarketOrder(symbol, side: side, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createLimitBuyOrder (symbol: String, amount: Double, price: Double, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.createLimitBuyOrder(symbol, amount: amount, price: price, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createLimitSellOrder (symbol: String, amount: Double, price: Double, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.createLimitSellOrder(symbol, amount: amount, price: price, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createMarketBuyOrder (symbol: String, amount: Double, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.createMarketBuyOrder(symbol, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createMarketSellOrder (symbol: String, amount: Double, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.createMarketSellOrder(symbol, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchMarketLeverageTiers (symbol: String, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchMarketLeverageTiers(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createPostOnlyOrder (symbol: String, type: OrderType, side: OrderSide, amount: Double, price: Double? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (price != nil) { paramsCopy["price"] = price }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.createPostOnlyOrder(symbol, typeVar: type, side: side, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createReduceOnlyOrder (symbol: String, type: OrderType, side: OrderSide, amount: Double, price: Double? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (price != nil) { paramsCopy["price"] = price }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.createReduceOnlyOrder(symbol, typeVar: type, side: side, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createStopOrder (symbol: String, type: OrderType, side: OrderSide, amount: Double, price: Double? = nil, triggerPrice: Double? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (price != nil) { paramsCopy["price"] = price }
					if (triggerPrice != nil) { paramsCopy["triggerPrice"] = triggerPrice }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.createStopOrder(symbol, typeVar: type, side: side, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createStopLimitOrder (symbol: String, side: OrderSide, amount: Double, price: Double, triggerPrice: Double, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.createStopLimitOrder(symbol, side: side, amount: amount, price: price, triggerPrice: triggerPrice, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createStopMarketOrder (symbol: String, side: OrderSide, amount: Double, triggerPrice: Double, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.createStopMarketOrder(symbol, side: side, amount: amount, triggerPrice: triggerPrice, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchLastPrices (symbols: Strings = nil, params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: [String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchLastPrices(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchTradingFees (params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: [String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchTradingFees(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchTradingFee (symbol: String, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchTradingFee(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchConvertCurrencies (params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: [String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchConvertCurrencies(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchFundingRate (symbol: String, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchFundingRate(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchFundingInterval (symbol: String, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchFundingInterval(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchMarkOHLCV (symbol: String, timeframe: String = "1m", since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[Double]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[Double]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchMarkOHLCV(symbol, timeframe: timeframe, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[Double]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchIndexOHLCV (symbol: String, timeframe: String = "1m", since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[Double]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[Double]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchIndexOHLCV(symbol, timeframe: timeframe, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[Double]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchPremiumIndexOHLCV (symbol: String, timeframe: String = "1m", since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[Double]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[Double]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchPremiumIndexOHLCV(symbol, timeframe: timeframe, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[Double]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchTransactions (code: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (code != nil) { paramsCopy["code"] = code }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchTransactions(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchPositionHistory (symbol: String, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchPositionHistory(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchPositionsHistory (symbols: Strings = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchPositionsHistory(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchTransfer (id: String, code: String? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (code != nil) { paramsCopy["code"] = code }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchTransfer(id, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchTransfers (code: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (code != nil) { paramsCopy["code"] = code }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchTransfers(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


}
